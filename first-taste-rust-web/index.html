<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="/statics/style.css">
    <link rel="alternate" type="application/rss+xml" title="你好，耳先生" href="/rss.xml" />
    <title>Rust Web初试</title>
</head>

<body>


    <section class="full-page">
        <section class="container">
            <nav>
                <a href="/">HOMEPAGE</a>
                
                
                <a href="/portfolios">PORTFOLIOS</a>
                
                <a href="/my-read">READINGS</a>
                
                <a href="/about">ABOUTME</a>
                
                
            </nav>
            <section class="single article">
                <p class="mate">January 06, 2017</p>
                <h2>Rust Web初试</h2>
                <section class="content yue line-numbers">
                    <p>Rust 是最近中意的一门语言。相比于 C 和 C++，我更加喜欢 Rust 的语法。</p>
<p>奈何 Rust 的学习曲线太陡了，一直都只能在入门阶段徘徊，没能深入了解 Rust。 个人感觉最大的问题在于没能搞懂 Rust 的所有权、引用借用和生命周期三个方面。</p>
<p>因此，我尝试着用 Rust 来进行 Web 开发，从而加深对 Rust 语法的了解。</p>
<!--more-->
<p>我选用的是 Iron 这个 Web 框架。本质上讲 Iron (或者说 Rust 的Web框架)都不能做到像 RoR、Django、Lavaral 那样一站式开发。 Iron 给我的感觉就像 Python 中的 Flask， 甚至更像 Node.js 中的 Koa。</p>
<p>这篇文章尝试介绍下 Iron 这个框架的编写流程，和给予想学习 Rust 的小伙伴们一些帮助和著者的些许理解。</p>
<p>环境选择 Rust + Iron + Tera</p>
<p>项目模型是 TODOLIST</p>
<h2>Iron 基本介绍</h2>
<p>Iron 组件的基本介绍：</p>
<ul>
<li><code>Iron</code> Iron 主类，用以启动HTTP服务器</li>
<li><code>Router</code> 路由类，属于 Handler</li>
<li><code>Chain</code> 中间件链类，用于处理 Handler、AfterMiddleware、BeforeMiddleware、AroundMiddleware</li>
</ul>
<p>Iron 的组织方式是 MVC：</p>
<ul>
<li>MODEL 层用来定义 Web 中用到的模型。通常使用 ORM</li>
<li>VIEW 层是模版渲染</li>
<li>CONTROLLER 层用来控制业务逻辑</li>
</ul>
<p>所以我们根据 MVC 的模式来建立项目结构，在你的 Rust 项目(用 Cargo 创建)<code>src</code>文件夹中的结构是这样的：</p>
<pre><code>src/
|----controllers
|----|----todo.rs
|----|----mod.rs
|----routers.rs
|----models.rs
|----lib.rs
|----main.rs
</code></pre>
<ul>
<li><code>controllers</code> 文件夹中放的是 CONTROLLER 层的内容， 文件夹内的文件就是 CONTROLLER 分类，分模块编写。</li>
<li><code>routers.rs</code> 用来单独处理路由</li>
<li><code>models.rs</code> MODEL 定义文件</li>
<li><code>lib.rs</code> RUST LIB 格式文件，告知 Rust 这是一个库项目</li>
<li><code>main.rs</code> RUST APP 格式文件，项目入口文件。</li>
</ul>
<h2><code>Cargo.toml</code></h2>
<p>我们把项目名称称为 <code>todolist</code> ， <code>cargo.toml</code> 的依赖信息如下：</p>
<pre><code class="language-toml">[dependencies]
iron = &quot;*&quot;
router = &quot;*&quot;
tera = &quot;*&quot;
diesel = &quot;*&quot;
lazy_static = &quot;*&quot;
</code></pre>
<ul>
<li><code>iron</code> Iron Web 框架</li>
<li><code>router</code> Iron Router 库</li>
<li><code>tera</code> 模版解析库</li>
<li><code>diesel</code> PostgreSQL 的 ORM 库</li>
<li><code>lazy_static</code> 延迟加载库</li>
</ul>
<h2><code>lib.rs</code> 分析</h2>
<pre><code class="language-rust">extern crate iron;
extern crate router;

pub mod controllers;
pub mod models;
pub mod routers;
</code></pre>
<ul>
<li>引用了了两个外部库 <code>iron</code>, <code>router</code></li>
<li>定义了三个子模块 <code>controllers</code>, <code>models</code>, <code>routers</code></li>
</ul>
<h2><code>model.rs</code></h2>
<pre><code class="language-rust">
struct ToDoItem {
    item_id: i32,
    value: String,
    done: bool,
}
pub struct ToDoList {
    list : Vec&lt;ToDoItem&gt;,
}

impl ToDoList {
    pub fn add(&amp;self, value: &amp;str) {
        // some code
    }

    pub fn delete(&amp;self, item_id: i32) {
        // some code
    }
}
</code></pre>
<p>这里不多解释，因为使用 ORM 和不使用的MODEL是不一样的。所以不过多分析，这里只是定义了两个结构而已。</p>
<h2><code>controllers</code></h2>
<p>该文件夹中有两个文件 <code>mod.rs</code>， <code>todo.rs</code></p>
<h3><code>mod.rs</code></h3>
<pre><code class="language-rust">pub mod todo;
</code></pre>
<p>这个文件只是告知该文件夹中有几个子模块，这里定义了一个模块 <code>todo</code>。 这是 Rust 的模块定义的固定格式。详情查看 Rust 官方文档。</p>
<h3><code>todo.rs</code></h3>
<p>这里是我们自己定义的关于 TODOLIST 业务的 CONTROLLER</p>
<pre><code class="language-rust">use iron::status;
use iron::prelude::*;

pub fn todo_show(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
    Ok(Response::with((status::Ok, &quot;todo list&quot;)))
}

pub fn todo_add(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
    Ok(Response::with((status::Ok, &quot;add page&quot;)))
}
pub fn todo_delete(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
    Ok(Response::with((status::Ok, &quot;delete page&quot;)))
}
</code></pre>
<p>这个文件按照 Iron 框架处理函数的格式写了三个函数(都是简单的返回纯文本)。</p>
<h2><code>routers.rs</code></h2>
<pre><code class="language-rust">use router::Router;
use controllers::todo::*;

pub fn router_generator() -&gt; Router {
    let mut router = Router::new();
    router.get(&quot;/&quot;, todo_show, &quot;todo_show&quot;);
    router.post(&quot;/add&quot;, todo_add, &quot;todo_add&quot;);
    router.post(&quot;/delete&quot;, todo_delete, &quot;todo_delete&quot;);
    router
}
</code></pre>
<p>router 的构建函数， 在内部把刚刚写的几个 CONTROLLER 添加至路由中。</p>
<h2><code>main.rs</code></h2>
<pre><code class="language-rust">extern crate iron;
#[macro_use]
extern crate tera;
#[macro_use]
extern crate lazy_static;

extern crate todolist;

use iron::prelude::Iron;
use tera::{Tera, Context};
use yolk::routers::router_generator;


// 延迟渲染模版
lazy_static! {
    pub static ref TEMPLATES: Tera = {
        let tera = compile_templates!(&quot;templates/**/*&quot;);
        tera
    };
}


fn main() {
    // 启动 Iron 服务器
    let _server = Iron::new(router_generator()).http(&quot;localhost:3000&quot;).unwrap();
    println!(&quot;On 3000&quot;);
}
</code></pre>
<ul>
<li>引入几个外部模块 <code>iron</code>, <code>lazy_static</code></li>
<li>引入自己这个模块 <code>todolist</code></li>
<li>使用刚刚写的<code>router_generator</code> 函数来作为 <code>Handler</code> 启动 Iron</li>
</ul>
<h2>TEMPLATE 库的一些看法</h2>
<p>Rust 在 Web 这个方向发展并没有太快。所以在模版上并没有太多优质 的库。在我看来，有两个库是值得参考一下的。</p>
<ul>
<li><a href="https://github.com/Keats/tera">Tera</a></li>
<li><a href="https://github.com/sunng87/handlebars-iron">Handlebars-iron</a></li>
</ul>
<p><code>handlebars-iron</code> 基本符合 Iron 的设计思想，采用 <code>AfterMiddleWare</code> 的思想，对 Controller 的入侵是最小的，而且还可以做到 watch 特性，即无需重启进程都可以重新渲染模版（Rust 是编译性语言，进程执行后就已经把模版渲染好了，所以修改模版文件并不会自动生效。）。有兴趣的可以读者自己阅读相关文献。</p>
<p>著者是中意 Tera 更多的，一下是 Tera 的简单使用：</p>
<pre><code class="language-rust">// 延迟加载模版渲染
lazy_static! {
    pub static ref TEMPLATES: Tera = {
        let tera = compile_templates!(&quot;templates/**/*&quot;);
        tera
    };
}

fn main() {
    let context = Context::new(); // 参数类
    context.add(&quot;KEY&quot;, &quot;VALUE&quot;); // 添加一个参数
    let content = TEMPLATES.render(&quot;test.html&quot;, context); // 渲染 test.html 这个模版，返回的是 Optional
}
</code></pre>
<p>如果要使用在 Iron 中，大致是这样的：</p>
<pre><code class="language-rust">pub fn todo_show(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
    let context = Context::new(); // 参数类
    context.add(&quot;KEY&quot;, &quot;VALUE&quot;); // 添加一个参数
    let content = TEMPLATES.render(&quot;test.html&quot;, context);
    Ok(Response::with((status::Ok, content.unwrap()))
}
</code></pre>
<p>说 Iron 完成度低的原因就在于，返回的类型是 IronResult. 并没有做到直接返回 RUST 基本类型即可。</p>
<p>不过有能力者可以自己写一个宏来处理。</p>
<h2>对于 ORM 的一些看法</h2>
<p>ORM 的使用不方便大概是我放弃用 Rust 写 Web 的主要原因之一。实在是太不优雅了。</p>
<p><a href="https://github.com/diesel-rs/diesel">Diesel</a> 是我在那么多 ORM 中比较中意的一个，只支持 PostgreSQL。
感兴趣的读者可以关注一下。</p>
<h2>关于 Iron</h2>
<p>Iron 目前对于使用者来说，就是写很多很多的 MiddleWare， 然后用 <code>Chain</code> 类串联起来。 并不能最太多的东西。如果偏要写很多的东西的话，你会发现直接用底层的<code>hyper</code>库直接重新实现一个 Web 框架更为实际。</p>
<p><code>Router</code> 类的使用也是挺不方便的，并不能很轻易地让一个 CONTROLLER 绑定在同一链接的两个方法上。这个设计的初衷也是很好的，避免无畏的可访问页面。</p>
<h2>结言</h2>
<p>文章就写完了，主要讲的是怎么构建一个可以扩展的网站框架，而不是网站实现的细节。
希望你有所收获，同时也希望有更多的人喜欢 Rust 这门优雅的语言。</p>

                </section>
            </section>
        </section>
    </section>


    <footer>
        <section class="container">
            <p> 自豪地使用 <a href="https://github.com/Kilerd/rubble">Project Rubble</a> 运行。 </p>
            <div style="display:none"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-68997851-1"></script> <script>   window.dataLayer = window.dataLayer || [];   function gtag(){dataLayer.push(arguments);}   gtag('js', new Date());    gtag('config', 'UA-68997851-1'); </script>
</div>
        </section>
    </footer>
    <script src="/statics/prism.js" type="text/javascript"></script>
</body>

</html>