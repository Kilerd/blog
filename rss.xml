<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>你好，耳先生</title>
        <link>https:&#x2F;&#x2F;www.kilerd.me</link>
        <atom:link href="https:&#x2F;&#x2F;www.kilerd.me/rss.xml" rel="self" type="application/rss+xml" />
        <description>先生贵姓？耳东陈。好的，这边请，耳先生。</description>
        <language>zh-CN</language>
        <generator>Staple</generator>
        
            
        <item>
            <title>狗子的一天</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/days-of-dogs</link>
            
            <description><![CDATA[<blockquote>
<p>有一种思念叫你家的狗子在想你</p>
</blockquote>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/days-of-dogs</guid>
            <pubDate>Fri, 05 Mar 2021 22:13:03 +0800</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>有一种思念叫你家的狗子在想你</p>
</blockquote>
<!--more-->
<h2>旺旺</h2>
<p>我家在农村，在家附近有一块老妈围起来的菜地，一半种青菜，一半养鸡。同时妈子还养了两条狗，一条黄白色，一条黄黑色；一条住在菜园子的东南角，一条住在西北侧，每天遥遥相望；一条叫旺旺，另外一条也叫旺旺。由于村里偷狗现象很严重，所以旺旺是一年四季一日三餐都是锁在菜园子里面的，活动空间只有狗窝附近的一平米地。</p>
<p>我也不知道狗子它知不知道它自己叫旺旺，也知不知道另外一只也叫旺旺。但是奇怪的是，每次一喊旺旺永远都只会有一个狗子回应你，似乎它们之间达成了某种奇怪的协议，每狗每天轮流上班8个小时。</p>
<h2>幸运还是悲哀</h2>
<p>旺旺是母的，同时也是幸运的，相比于旺旺她被允许晚上松开狗链，因此她获得了夜晚整个菜园子的制霸权，旺旺只能蹲在自己的窝里面眼巴巴地看着她欢腾飞跃。当然，自由是有代价的，有一次旺旺利用漏洞钻入了菜地，弄死了很多白菜花菜，随即而来的是一顿来自母亲慈祥的打以及“禁闭”数天。</p>
<p>旺旺是公的，是悲哀的也是幸运的。他的品相很好，即便养在黄泥地里面，他的毛发都亮呼呼的，蓬松地不想一只狗子，反而更像一只小狮子。但就因为是狮子，叫声洪亮，凶恶的他终日无法脱离狗链的束缚，用我妈的话来说“晚上放两个狗出来菜园都可以给你拆了”，他是悲哀的。幸运的是旺旺很爱他，每天晚上被放出来的旺旺绕着菜园子跑几圈、上完厕所就主动回来陪他，直至早上。虽然说脖子上长年挂着狗链，但是一到晚上的相遇相见似乎可以冲淡这一切。</p>
<h2>生产事故</h2>
<p>直到有一天，干柴烈火的她们嘛，总要干出一些大事，不出我们所料，旺旺怀孕了，这是听我妈说的，我可没在家里看着。狗嘛，在基因里面就写好了如何生娃如何养娃的能力，所以我们就没怎么理旺旺，依旧遵循这白天锁晚上放的放风策略。</p>
<p>在某一天的很早的早上，我妈听到了旺旺发出的不同寻常的嘤嘤声，只在阳台上看了一眼确认了旺旺的安全就没有多理，直到早上进入菜园才发现刚出生没多久、还没看眼的小狗子掉进菜园子中间的鱼塘里面了。又由于旺旺平时没有下水游玩的习惯，只能在边上嘤嘤地叫。最终就酿出了这局惨案，可惜了那两个还没看眼只是在到处找奶吃的小狗子。旺旺也因为这事抑郁了好几天。</p>
<h2>过年</h2>
<p>过年这件大事并不是对人类有重大的意义，对旺旺而言同时也是“重获天日”的一段日子。因为我的回去，旺旺每天都能获得二十分钟左右的游玩时间，那是唯一一段可以看一眼村子的时刻。</p>
<p>由于我家只有一条多余的狗链，放风一次只能放一个。只要你敢放旺旺出来，那么旺旺绝对对急得乱蹦，口吐芬芳地乱叫，如果我听得懂狗语，那旺旺大致说的应该是“你怎么放它出来？我呢？你怎么不放我？明明是我先摆尾的，明明是我先来的。WDNMD”。不过即便听不懂，看旺旺那个架势和语气，应该差不多就是这个意思。</p>
<p>只要你牵着一条狗子出现在另外一只的视野内，他都会嘤嘤地叫得不停，唯一的方法就是走远走远再走远，直到它看不到：“原来爱是会消失的，对吗” 便趴会自己的窝边上。</p>
<p>可能是天生骨骼惊奇，也可能是长时间没放风，狗子的力气极其大，甚至有种把你拽飞的节奏，20分钟的遛狗可以称得上一天的运动量了。</p>
<p>村里隔壁家散养了3条狗，每次我把那只狮子般的旺旺带出去溜时，他们都需要紧紧地站在一团，生怕我家的旺旺会手撕了落单的他们，实际上旺旺温柔地很，就是除了力气大一点以外。</p>
<h2>再次生产</h2>
<p>年后离开家的不只是我的人和思绪，还有旺旺对我的一丝牵挂，那一份遨游村子的盼念。同时旺旺也再次怀了孕，这一次我和我妈讨论了很多怎么看护小狗子的事宜。可惜的是在临走一天还是等不到她生产的那一刻。</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>你可能真的不那么需要复式记账</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/things-about-double-entry-accounting</link>
            
            <description><![CDATA[<p>我翻了翻 GitHub 上面的项目记录，从2019年的2月开始初始化了记账项目的代码库，到现在2021年的近2月，也该是时候说一说我这两年来设计到的记账心路历程。</p>
<p>关于记账这件事早就已经是一篇红海，做的人很多，死的更多。无数项目突然涌现出来而后又死得消无声息。这篇文章会从几个方面来细数为什么我们那么喜欢记账而又坚持不下来：流水账与复式记账、趣味性与专业性、自动入账与手动入账。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/things-about-double-entry-accounting</guid>
            <pubDate>Wed, 03 Feb 2021 18:44:53 +0800</pubDate>
            <content:encoded><![CDATA[<p>我翻了翻 GitHub 上面的项目记录，从2019年的2月开始初始化了记账项目的代码库，到现在2021年的近2月，也该是时候说一说我这两年来设计到的记账心路历程。</p>
<p>关于记账这件事早就已经是一篇红海，做的人很多，死的更多。无数项目突然涌现出来而后又死得消无声息。这篇文章会从几个方面来细数为什么我们那么喜欢记账而又坚持不下来：流水账与复式记账、趣味性与专业性、自动入账与手动入账。</p>
<!--more-->
<h2>流水账与复式记账</h2>
<p>流水账是指只记录了「花了多少钱在什么事情上」，比如「今天吃饭AA了100块」。看起来似乎确实满足了记账最简单的几个点：什么时候花的钱；为什么花了钱；花了多少钱。但是在对账的时候却很难定位到账单与记账的关联。</p>
<p>为了能更清晰地阐述流水账与复式记账的区别，我会根据「AA吃饭」这个例子给出一个更加具体的场景。</p>
<blockquote>
<p>1月1号，你跟 A 先生与 B 先生出去吃了一顿饭，一共300块，AA下来每人100块，于是你先用微信支付了300块。</p>
<p>1月3号，A 先生转了100块到你的支付宝账户。</p>
<p>B 先生作为一个老赖，「无意」地忘记了还你钱，同时把你拉黑了。</p>
</blockquote>
<p>那么对于流水账来说你可能记录了两笔账：</p>
<ul>
<li>1月1号，吃饭消费 300 块</li>
<li>1月3号，A先生转账100块作为AA平摊费用</li>
</ul>
<p>那么随即而来会有几个比较明显的问题：</p>
<ul>
<li>为什么我这个月吃饭的钱花了那么多？</li>
<li>还有100块钱的差额去了哪里？（如果你还记得B先生没有还你100块的话。）</li>
<li>当前你的微信支付还有多少钱？支付宝账户呢？</li>
</ul>
<p>总结下来流水账的弱点出现在资产流动不明确与资产占比不明确上，复式记账比较好地解决了这几个问题。</p>
<h3>复式记账</h3>
<blockquote>
<p>在会计学中，复式簿记（又称为复式记账法）是商业及其他组织上记录金融交易的标准系统。</p>
<p>该系统之所以称为复式簿记，是因为每笔交易都至少记录在两个不同的账户当中。每笔交易的结果至少被记录在一个借方和一个贷方的账户，且该笔交易的借贷双方总额相等，即“有借必有贷，借贷必相等”。</p>
<p>例如，如果A企业向B企业销售商品，B企业用即期支票向A企业支付货款，那么A企业的会计就应该在贷方记为“销售收入”，在借方记为“现金”。相反地，B企业的会计应该在借方记为“进货”，并在贷方记为“银行存款”。</p>
<p>借方项目通常记在左边，贷方则记在右边，空白账簿看起来像个T字，故账户也被称为T字帐。</p>
</blockquote>
<p>复式记账来自于会计行业的专业术语，简单来说我们要记录每一次交易的来源与去向（在会计学中称之为 credit 和 debit）。那么我们通过这种方式来分析刚刚举的AA吃饭例子。</p>
<blockquote>
<p>1月1号，你跟 A 先生与 B 先生出去吃了一顿饭，一共300块，AA下来每人100块，于是你先用微信支付了300块。</p>
</blockquote>
<p>300块看起来是从「微信账户」流转到了「消费:吃饭」账户，但是实际并不是，因为对于账户所有人来说，只花了100在「消费:吃饭」上，剩下的200块实际上是用一种类似信贷的方式由你借给了A先生和B先生。所以对于复式记账来讲，这里要拆开三条记录：</p>
<ul>
<li>100块: 「微信账户」流转到「消费:吃饭」</li>
<li>100块: 「微信账户」流转到「借款:A先生」</li>
<li>100块: 「微信账户」流转到「借款:B先生」</li>
</ul>
<p>自此我们解决了上述说得第一个问题「为什么我这个月吃饭怎么花了那么多钱」。复式记账的好处之一就体验出来了：你可以把一笔交易拆成很多细小的组成部分。如果要举另外一个例子的话可以是工资收入，你的3000月薪实际上是从「公司」账户流转到了「银行卡」「公积金」「医疗保险」「养老金」等数个账户，这也能统计出来你为国家交了多少税。</p>
<blockquote>
<p>1月3号，A 先生转了100块到你的支付宝账户。</p>
</blockquote>
<p>对于这一条记录，很简单就是从「借款:A先生」流转到「支付宝账户」。自此 「借款:A先生」的余额从「100.00」抹平到「0.00」，意味着 A 先生不再欠你的钱。</p>
<blockquote>
<p>B 先生作为一个老赖，「无意」地忘记了还你钱，同时把你拉黑了。</p>
</blockquote>
<p>对于这位老赖并没有产生任何在记账上的记录，但是不要忘记了在第一笔的记录中，「借款:B先生」是被记录成了 「100.00」 的，那么这个情况，它再也不会消失。</p>
<p>依靠 「微信账户」「支付宝账户」「消费:吃饭」「借款:A先生」「借款:B先生」这几个账户的变动，我们可以成功的算平我们的收入与支出：</p>
<ul>
<li>「微信账户」 - 300.00</li>
<li>「支付宝账户」 + 100.00</li>
<li>「消费:吃饭」+ 100.00</li>
<li>「借款:A先生」0.00</li>
<li>「借款:B先生」 + 100.00</li>
</ul>
<p>得出来的总计是0.00，证明我们的记账流程并没有出现差错</p>
<p>这里可能有人比较纠结每个账户上面的正负是什么意思，这就是ledger-like app的优势，相比于传统的复式记账，一笔账需要在两个账户中同时记下一笔交易，ledger-like 使用了正负来代表了credit 方和 debit 方，一条记录就完成了传统的两次记录的复杂模式，也让交易更加人类易读。</p>
<h2>趣味性与专业性</h2>
<p>上部分介绍了流水账和复式记账的区别与复式记账相较于流水账的优势，这里会直击问题的本质：你真的那么需要复式记账吗？答案可能是否定的。在长时间的记账之后，统计发现，在绝大部分时间的交易都是简单地从一个账户到另外一个账户的划转（这里把消费也当做了一个独立的账户），那么复式记账其实会更加麻烦，因为现在的流水账软件也能够新建各种账户，所以复式记账的分账户记录也不再是一个比较突出的优势了。</p>
<p>对于例如工资收入、购房贷款、分期购物等一些在时间跨度上比较长的交易，在流水账的APP上也有类似的循环交易与拆分交易的功能。</p>
<p>同时流水账的APP普遍都做的比专业软件更加适合用户使用。记账是一件很枯燥很无赖也很费事的时间，APP就会抓住这个痛点：简化日常记账流程、美化记账界面、增加趣味功能。对于趣味性，有的APP把记账设计成是跟一个 IDOL 聊天，有的把界面设计成一个养成系游戏（记账城市的思路大赞）。很明显这些设计有很有效，确实抓住了一部分人的痛点。</p>
<p>相比于 ledger 和 beancount 的文字编辑型的记账模式，一来需要学习它特有的写法，二来没有比较用户友善的界面，三来没有APP。APP真的是当代的一个超级大的痛点，没有APP意味着你不能随时随地地在手机上记账，需要找一个专门的时间来记账，这会击退绝大部分的普通用户。</p>
<p>但是无论流水账的趣味性做的再好也能难撼动以 beancount 在部分注重资产流转的用户的地位。主要的原因有几：</p>
<p>一，对账功能真的是让复式记账的门槛再次降低，它指的是你可以对某一个时间点把账户的金额抹成一个你指定的数。这用于少记了某几笔金额极小的交易，账户日常派息等无法感知的情况。 这对于流水账APP来说是一个难以解决的问题，就会经常出现记着记着就发现软件上的账户余额跟真实的账户余额对不上，也很少人愿意一笔一笔地往下一笔一笔的核对，导致最后流水账软件上的信息不正确，这也是流水账用户“弃坑“的原因之一。</p>
<p>二，复杂而专业的查询与报表功能。绝大部分APP都无法针对性地定制自己的报表，只能给你一个账户消费占比，月度余额波动图等比较笼统而无用的报表，如果想做到「某几天因某原因在某地的消费总额」就需要使用beancount 中的查询功能，这也是这一类软件比较强化的点，分析为主。</p>
<h2>自动入账与手动入账</h2>
<p>自动入账在国内巨头垄断的局面下基本是不太可能的事情，市面上唯一一款能直接对接支付宝和银行卡账单的记账软件「网易有钱」也凭仗着自己也是巨头而做到了其他小型开发商做不到的事情。</p>
<p>想比如国外的信用卡广泛使用的场景不同，国内的消费习惯都是走第三方交易的，简单来说就是由于电子交易的普及，大家都习惯于用支付宝和微信支付，而在使用这两种支付方式的时候也是通过绑定银行卡来实现金额划转的。那么在银行卡的账单系统中就只能记录下从「银行卡」到「支付宝」的账面信息，这对记账是没有任何意义的，因为你不知道支付宝到底支付了什么东西，而真的交易信息存在了不怎么开放的支付宝里面，微信也是同理。</p>
<p>即便采用了账单导出的功能，那么银行卡账单于支付宝账单去重也是一件极其复杂和麻烦的事情。市面上也有不少半自动的从支付宝手动下载账单然后脚本导入的模式，但是本质上并没有解决这一个痛点。</p>
<h2>关于造轮子这件事</h2>
<p>对于我个人来说，Beancount这款复式记账软件已经够用了，也极大的降低了复式记账的复杂度。但是我这段时间还在模仿beancount造一个记账软件出来的意义，对于其他人来说可能不是痛点，但是对于我来说缺难以忍受。</p>
<p>我个人是有攒小票的习惯的，那么不能在交易上把小票等信息关联起来就是一个难以接受的事情，所以我为交易增加了一个附件的功能，它可以关联各种形式的文件，我现在用来关联购物小票，购物发票，借款声明等等。但是目前还没有办法把关联的图片直接显示出来，只能通过下载查看，这是一个比较大的问题。</p>
<p>上述说到日常的90%交易都是点对点的账户交易，beancount并没有优化这种交易的记录模式，我也是为了解决这个痛点，让日常记账更加容易和易读。</p>
<p>beancount中是有tag系统的，可以为交易挂上各种标签，比如说这些交易都是发送在某次旅行中的，但是这个「挂标签」的动作是每次交易都需要手动加上，所以我就自己写了一个事件系统，可以开始某个事件结束事件，在事件中记录软件会自动加上事件定义的标签，从而解决通过标签分类账单的问题。</p>
<p>为了可以延续beancount的生态，导出成beancount的文件，从而接入beancount强大查询功能也是在计划当中。</p>
<h3>广告</h3>
<p>如果你对记账感兴趣，而且有空，那么可以联系我，缺UX！缺前端！（如果能有人糊一个APP出来就更好了</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>2020：他说有点累了</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/summaries-my-2020</link>
            
            <description><![CDATA[<p>“你说，你觉得我是一个很菜的人吗？”我没有回答，只是静静地拿起了桌上的酒杯，事实上我也不知道怎么回答？</p>
<p>坐在我对面的是耳先生，我和他已经一年没有见面了。今天是圣诞节的晚上，很难得我可以把他约出来，但是坐下来已经快半个小时了，他才缓缓说出这句话。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/summaries-my-2020</guid>
            <pubDate>Sun, 10 Jan 2021 01:27:11 +0800</pubDate>
            <content:encoded><![CDATA[<p>“你说，你觉得我是一个很菜的人吗？”我没有回答，只是静静地拿起了桌上的酒杯，事实上我也不知道怎么回答？</p>
<p>坐在我对面的是耳先生，我和他已经一年没有见面了。今天是圣诞节的晚上，很难得我可以把他约出来，但是坐下来已经快半个小时了，他才缓缓说出这句话。</p>
<!--more-->
<p>我从他的眼里看出了一丝疲倦，我不知道他这一年里经历了什么，我也不知道怎么回答他，只能举起了酒杯跟他碰了一下，然后就等着他自己讲出他这一年碰到的事情。</p>
<p>我认识耳先生已经快有十年的时间了，他在我的印象中一直都是一个很勤奋很聪明的人，他身边的人都很习惯地碰到什么问题都会找他解答，耳先生他也是来者不拒。</p>
<p>“我感觉我这一年好像有这么荒废过去了，想学的没学好，还莫名的受了好几次气”他咕咕咕喝下一大口啤酒说。“不会啊，你不是还跟我说过你把好几个软件都写出来了吗？那个叫什么stap...”终于我能搭上了话。“哦，你说的是 staple啊，嗯我是把他快写完了”</p>
<p>对，就是Staple，按照他当时的说法，他要做一个静态博客生成器，就跟hugo那些一样。我是不知道Hugo是个什么东西，但是我知道静态博客生成器是什么。在他编写它的那一段时间里面有跟我保持联系，我们一直在讨论staple怎么设计好，需要做什么功能。虽然我不是一个互联网从业者，但是我从一个小白和使用者的角度跟他聊了很多很多，他也很会从一个通俗易懂的角度跟我阐释清楚。他这是把我当成了产品经理了。</p>
<p>我很佩服耳先生的一点就是他似乎拥有着无尽的动力去写自己感兴趣的东西，但是别人不知道的是他基本花光了他所有业余的时间在上面。他是我见过为数不多真正喜欢编程的人，同时我也挺替他感到惋惜的，这样优秀的人却在外包公司写着屎一样的代码。我也跟他聊过这点“要不你就准备准备，面一个BAT，以你的水平应该是进得去的”</p>
<p>“可我实在没办法忍受加班，那样我就没办法出去玩，没办法学习了”，也对。</p>
<p>“干了！”耳先生看着酒杯里面不多的啤酒，说出了这句话，然后我们的话题又回到了“菜”上面。</p>
<p>耳先生菜吗？这个疑问从他说出那句话开始我就在思考。你说他厉害吧，他的英文水平着实从高中开始就是每天都是被罚站的水平；你说他菜吧，他的逻辑思考能力确实又超出常人一丝。</p>
<p>“其实你还是挺优秀的啊，至少你同事对你的评价都是挺正面的啊”</p>
<p>耳先生深深叹了一口气，我也知道，他是那种一遍学不会就再学一遍的人。他说他花了那么多时间在上面才有那一点点的产出和收益，只能说明他真的没有这方面的天赋，他又举了几个TU毕业、咕咕噜上班、BAT上班的人，说他们平时聊的东西自己根本就没怎么接触过。“你看，差距就是这么来的了”。确实啊，这让我又想起了他提及过高中一个每天都在拼命学最后只刚刚达到重本线的女生。耳先生的一部分压力其实也来自于他公司内部，他公司里面有着数不胜数的 985 和海龟学生，每一个的资历都是吊打他的，在那个环境下我可能都会感到压抑。</p>
<p>想起了他英文课天天被罚站，我就想起了他要做的一个产品 <a href="http://resource.rs">Resource.rs</a> ，那一个他跟我讲的时候满眼放光的产品：“我要整合网络上关于 rust 的各种资讯、各种文章，给中文学习者一份很大很大的礼物”。到现在一年过去了，我估计是为数不多偶尔会点开看看更新情况的人，这个网站的内容已经很久很久没有更新了，本身就为数不多的内容很多都已经过时了。我本人是很欣赏这种想法的，把一个门槛很高的东西用简单化的语言讲述出来，这是一件很高尚的事情。“估计也只有程序员才那么傻愿意投入大量时间维护和撰写这种没什么收益的事情”我心里这样想，但是我没敢告诉耳先生。</p>
<p>耳先生跟我说他可能做不下去了，总结了一下价值有一下几个原因：</p>
<ul>
<li>能力不足。互联网上的资源是参差不齐的，为了筛选和总结这些内容意味着维护者需要有辨识这些内容的能力和产出总结文章的精力。那么这要求了维护者至少是一个rust精通使用者，耳先生自认为达不到这样的水平。而且这便随即带来另外一个问题，如果维护的内容很官方的话，那么这跟《TRPL》、《Rust by example》没有区别了。一个人靠业余的精力真的无法维护出那么精细的内容。</li>
<li>定位不明确。耳先生想把 <a href="http://resource.rs">Resource.rs</a> 定位成一个覆盖面广、知识准确的入门级资讯网站。但是实践出来的内容却更像是他个人的Rust学习历程。英文水平高的用户完全有能力阅读英文文章，中文社区又不能产生出比较又水平的文章，导致了这个网站的内容缺乏。</li>
</ul>
<p>其实，经常关注耳先生的都能发现他博客里面有着挺多关于 Rust 的博文，我有一次就比较好奇问耳先生：“为什么你不把你Rust的博文发到你那个Rust资讯网呢？”</p>
<p>“不是我不想啊，我自己也是刚开始学这方面的知识，连我都不知道这是对的还是错的，根本没有勇气把它放在网站上，就怕误导了别人，是不是？国外有个很好的 <a href="http://cheats.rs">cheats.rs</a> ，国内有 rust-lang-cn，有 <a href="http://rust.cc">rust.cc</a> 论坛。我真不知道我到底还能不能坚持下去。”</p>
<p>一阵晚风从耳边吹过，我们又陷入了短暂的沉默，独自地喝着酒，隔壁桌嘻嘻闹闹的声音时不时吹到我们桌来。</p>
<p>“哎，这段时间真的好累，我都想辞职休息一段时间了“ 两个酒杯又碰在了一起，打破了那一刻的沉默。“嗯，我好久之前就想这么做了“我附和道。</p>
<blockquote>
<p>我都不知道这一年我自己干了什么，感觉时间过得很快。眼睛刚闭上没几分闹钟就醒了，一眨眼就上班了，再一眨眼就下班了，一眨眼又深夜该睡了。</p>
<p>上班又经常犯错，被老板同事说。整天做着千遍一律的内容，还要跟自己公司的同事扯皮吵架，说好的我们公司同事间没有竞争压力呢？为什么会出现个问题都急迫着推卸责任。</p>
<p>还要被老板强制转岗，闹了好一阵子估计转岗培训里面对我的评价应该是最低的吧，反正今年的调薪估计是没我什么事的了。我实在想不到我的出名居然是因为我的犯错让几乎整个中国区的高层都听说过了我的名字，真的是太惨了。在这个公司估计是快混不下去了。</p>
<p>有时候我在想我是不是真的不适合这个行业，我上班看技术，下班看技术，周末看技术，还是没学会什么东西。总感觉自己陷入了「越菜越学，越学越菜」的困境里面。</p>
<p>每次在网络上看到其他人说我师从某某某，我跟某某某学技术的时候都很羡慕，感觉我平时都只能自己在瞎胡闹。做无用功估计说的就是我这种行为。</p>
<p>我很羡慕和佩服那些人。考上985院校、喜欢计算机、对逻辑数理敏感、有份好工作、身边有志同道合的人，每一项我都做不到。</p>
<p>哎，我也想这样啊。</p>
</blockquote>
<p>我知道这个时间不应该说话，我也不知道要说什么，只知道陪着他默默地喝酒。每个人都有每个人的难处，就像那句话说的“人与人的悲欢各不相同，我只觉得他们吵闹“，大家都没有嘲笑互相的资本，至少我没有嘲笑他的能力，哪怕他说的多么幼稚。</p>
<p>“也不早了，回吧”</p>
<p>“嗯，也该回了”</p>
<p>“好，那我走了”</p>
<p>“嗯，我也走了”</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>Rust 过程宏 101</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/rust-proc-macro-101</link>
            
            <description><![CDATA[<p>在 Rust 1.45 中，Rust 的<ruby>卫生宏<rp>(</rp><rt>Hygienic macro</rt><rp>)</rp></ruby>迎来了 stable 版本，这意味着<ruby>过程宏<rp>(</rp><rt>Procedural macro</rt><rp>)</rp></ruby>和<ruby>声明宏<rp>(</rp><rt>Declare macro</rt><rp>)</rp></ruby>板块全面稳定。那么是时候该认真学习一边过程宏的内容了。</p>
<p>过程宏相比于声明宏的灵活度更加高，其本质是输入一段 Rust 的 AST 产生一段 AST 的函数，同时 Rust 提供了三种不一样的语法糖来满足不同的使用场景。</p>
<ul>
<li><ruby>函数式<rp>(</rp><rt>Function-like</rt><rp>)</rp></ruby>的宏 - 这跟声明宏很类似</li>
<li>Derive 宏 - <code>#[derive(CustomDerive)] </code> - 一个用于结构体和枚举类型的宏</li>
<li><ruby>参数宏<rp>(</rp><rt>Attribute macros</rt><rp>)</rp></ruby> - <code>#[CustomAttribute]</code> </li>
</ul>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/rust-proc-macro-101</guid>
            <pubDate>Thu, 11 Jun 2020 18:43:26 +0800</pubDate>
            <content:encoded><![CDATA[<p>在 Rust 1.45 中，Rust 的<ruby>卫生宏<rp>(</rp><rt>Hygienic macro</rt><rp>)</rp></ruby>迎来了 stable 版本，这意味着<ruby>过程宏<rp>(</rp><rt>Procedural macro</rt><rp>)</rp></ruby>和<ruby>声明宏<rp>(</rp><rt>Declare macro</rt><rp>)</rp></ruby>板块全面稳定。那么是时候该认真学习一边过程宏的内容了。</p>
<p>过程宏相比于声明宏的灵活度更加高，其本质是输入一段 Rust 的 AST 产生一段 AST 的函数，同时 Rust 提供了三种不一样的语法糖来满足不同的使用场景。</p>
<ul>
<li><ruby>函数式<rp>(</rp><rt>Function-like</rt><rp>)</rp></ruby>的宏 - 这跟声明宏很类似</li>
<li>Derive 宏 - <code>#[derive(CustomDerive)] </code> - 一个用于结构体和枚举类型的宏</li>
<li><ruby>参数宏<rp>(</rp><rt>Attribute macros</rt><rp>)</rp></ruby> - <code>#[CustomAttribute]</code> </li>
</ul>
<!--more-->
<h2>行为影响</h2>
<p>这三种宏的的效果也不完全一致。 <ruby>函数式宏<rp>(</rp><rt>Function-like macro</rt><rp>)</rp></ruby> 和 <ruby>参数宏<rp>(</rp><rt>Attribute macros</rt><rp>)</rp></ruby> 拥有<strong>修改原AST</strong>的能力，而Derive 宏就只能做追加的工作。</p>
<h3><ruby>函数式宏<rp>(</rp><rt>Function-like macro</rt><rp>)</rp></ruby></h3>
<pre><code class="language-rust">#[proc_macro]
pub fn my_macro(INPUT_TOKEN_STREAM) -&gt; TokenStream {
    OUTPUT_TOKEN_STREAM
}

my_macro!(INPUT_TOKEN_STREAM)
</code></pre>
<p>经过编译之后，6L 就会被<strong>替换</strong>成 <code>OUTPUT_TOKEN_STREAM</code></p>
<h3>Derive 宏</h3>
<pre><code class="language-rust">#[proc_macro_derive(MyMacro)]
pub fn derive_my_macro(INPUT_TOKEN_STREAM) -&gt; TokenStream {
	OUTPUT_TOKEN_STREAM
}

#[derive(MyMacro)]
struct MyStruct {...}
</code></pre>
<p>经过编译之后， 6-7L 就会被编译成以下：</p>
<pre><code class="language-rust">#[derive(MyMacro)]
struct MyStruct {...}

OUTPUT_TOKEN_STREAM
</code></pre>
<p>可见，原来的 <code>MyStruct</code> 并不会被影响，也无法改变，而能做的只是在其后追加新的AST，通常用来生成 <code>Builder</code> 和 <code>impl Blabla for MyStruct</code> 从而改变<code>MyStruct</code> 的行为。</p>
<h3><ruby>参数宏<rp>(</rp><rt>Attribute macros</rt><rp>)</rp></ruby></h3>
<pre><code class="language-rust">#[proc_macro_attribute]
pub fn my_macro(ATTR_TOKEN_STREAM, INPUT_TOKEN_STREAM) -&gt; TokenStream {
    OUTPUT_TOKEN_STREAM
}

#[my_macro(a=1,b=2)]
fn method() {...}
</code></pre>
<p>在这个例子中</p>
<ul>
<li><code>ATTR_TOKEN_STREAM</code> 为 <code>a=1, b=2</code></li>
<li><code>INPUT_TOKEN_STREAM</code> 为 <code>fn method() {...}</code></li>
</ul>
<p>而编译之后， 6-7L 编译成 <code>OUTPUT_TOKEN_STREAM</code></p>
<h2>入门例子使用</h2>
<p>了解了过程宏的相关基本知识之后呢，就可以根据自己的需求选择不同的实现方式来简化代码。下面会以一个例子来介绍怎么设计一个 Derive 宏，不感兴趣的可以跳过这个章节。 </p>
<p>该章节的代码实现已经放在了 <a href="https://github.com/Kilerd/rust-derive-macro-demo">Github kilerd/rust-derive-macro-demo</a></p>
<h3>非过程宏实现</h3>
<p>在一次业务实现中，需要根据错误类型返回前端不同的错误码和消息。这意味着我们对于不同的错误需要三个不同的字段</p>
<ul>
<li>HTTP <ruby>返回码<rp>(</rp><rt>status code</rt><rp>)</rp></ruby></li>
<li>错误的 Code</li>
<li>错误的具体描述内容</li>
</ul>
<p>返回给前端的结构是这样的</p>
<pre><code class="language-json">{
    &quot;code&quot;: &quot;INVALID_EMAIL&quot;,
    &quot;message&quot;: &quot;Invalid email&quot;
}
</code></pre>
<p>对于Java来说，这很容易用一个枚举类型来描述这样的需求：</p>
<pre><code class="language-java">public enum BusinessError {

    InvalidEmail(400, &quot;INVALID_EMAIL&quot;, &quot;Invalid email&quot;),
    InvalidPassword(400, &quot;INVALID_Password&quot;, &quot;Invalid password&quot;);

    int httpCode;
    String code;
    String message;
    BusinessError(int httpCode, String code, String message) {
        this.httpCode = httpCode;
        this.code = code;
        this.message = message;
    }
}
</code></pre>
<p>在这种情况下需要增加错误类型的时候，只需要在 4L 处新增即可，影响的范围不大。</p>
<p>而对于Rust来说，<ruby>枚举类型<rp>(</rp><rt>enum</rt><rp>)</rp></ruby>更加像是一种数据结构，所以无法像 Java 一样在 3-4L 里面储存这样的信息，为了达成同样的效果，我们需要在函数里面自己实现返回的内容：</p>
<pre><code class="language-rust">pub enum BusinessError {
    InvalidEmail,
    InvalidPassword
}

impl BusinessError {
    pub fn get_http_code(&amp;self) -&gt; u16 {
        match self {
            BusinessError::InvalidEmail =&gt; 400,
            BusinessError::InvalidPassword =&gt; 400,
        }
    }
    pub fn get_code(&amp;self) -&gt; String {
        match self {
            BusinessError::InvalidEmail =&gt; String::from(&quot;INVALID_EMAIL&quot;),
            BusinessError::InvalidPassword =&gt; String::from(&quot;INVALID_PASSWORD&quot;),
        }
    }
    pub fn get_message(&amp;self) -&gt; String {
        match self {
            BusinessError::InvalidEmail =&gt; String::from(&quot;Invalid email&quot;),
            BusinessError::InvalidPassword =&gt; String::from(&quot;Invalid password&quot;),
        }
    }
}
</code></pre>
<p>实际看起来问题也不是很大，可以很好的完成业务需求，但是考虑一下增加错误类型这个业务场景，那么就需要在 3L，10L，16L，22L处做修改，影响的范围就很大了。</p>
<p>同时我们可以很轻松的看得出来对于 <code>get_code</code> 和 <code>get_message</code> 都是对枚举值进行简单的字面格式转换，那么人工做这么一件事件是很耗时的。这个时候就可以让过程宏代替我们实现 <code>impl BusinessError {...}</code> 里面的所有内容。</p>
<h3>Derive 宏的建立</h3>
<p>为了简化代码，我们决定把 <code>BusinessError</code> 改造成以下的格式：</p>
<pre><code class="language-rust">#[derive(DetailError)]
pub enum BusinessError {
    InvalidEmail,
    #[detail(code=400, message=&quot;this is an invalid password&quot;)]
    InvalidPassword
}
</code></pre>
<p>对于错误类型 <code>InvalidEmail</code> ，我们默认返回 httpCode <code>400</code>， code <code>INVALID_EMAIL</code> ， message <code>Invalid email</code>。但是我们可以通过 <code>#[detail(code, message)]</code> 来定制化 <code>httpCode</code> 和 <code>message</code>。</p>
<p>我们先拟定需要创建的宏的名称为 <code>DetailError</code> 。那么第一步先把项目改成 workspace 的目录结构。然后在其下面新增一个 <code>detail_error </code>的lib。</p>
<pre><code class="language-toml">[workspace]
members = [&quot;.&quot;, &quot;detail_error&quot;]

[dependencies]
detail_error = {path=&quot;./detail_error&quot;}
</code></pre>
<p>通过 <code>cargo new detail_error --lib</code> 创建好 lib 后，需要对 <code>detail_error/Cargo.toml</code> 增加「这个库是过程宏库」才可以访问到 <code>proc_macro</code> 这么一个特殊的库。</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>其后，在 <code>detail_error/lib.rs</code> 中声明过程宏处理函数：</p>
<pre><code class="language-rust">use proc_macro::TokenStream;

#[proc_macro_derive(DetailError, attributes(detail))]
pub fn detail_error_fn(input: TokenStream) -&gt; TokenStream {
    &quot;&quot;.parse().unwrap()
}
</code></pre>
<p>自此，我们的代码就不会报错了，但是我们还没有在<code>detail_error_fn</code> 里面返回我们期望的 <code>impl BusinessError{...}</code> 的 AST。实际上这个宏没有做任何事情。</p>
<h3>实现 <code>get_http_code</code> 方法</h3>
<p>第一步，我们需要先把<code>TokenStream</code> 格式化成我们期望的枚举结构。那么就用到了 <code>syn</code> 库，这个库提供了<code>parse_macro_input!</code> 这个宏来更加方便得访问 AST，在我们把 <code>TokenStream</code> 格式化成 <code>ItemEnum</code> 后就可以用<code>dbg!</code> 来查看其内部的数据了。</p>
<pre><code class="language-rust">let enum_struct = parse_macro_input!(input as syn::ItemEnum);
dbg!(enum_struct);
</code></pre>
<pre><code class="language-rust">enum_struct = ItemEnum {
    attrs: [],
    vis: Public(...),
    enum_token: Enum,
    ident: Ident { ident: &quot;BusinessError&quot;, span: #0 bytes(64..77),},
    generics: Generics {...},
    brace_token: Brace,
    variants: [
        Variant {
            attrs: [],
            ident: Ident {ident: &quot;InvalidEmail&quot;, span: #0 bytes(84..96),},
        },
        Comma,
        Variant {
            attrs: [...],
            ident: Ident { ident: &quot;InvalidPassword&quot;, span: #0 bytes(165..180),},
        },
    ],
}

</code></pre>
<p>在这里我们先 hardcode 所有的返回值是 <code>400</code>，先不理会在 <code>#[detail]</code> 中的配置，那么我们最关心的是</p>
<ul>
<li><code>.ident</code> - 枚举的名字</li>
<li><code>.variants[].ident</code> - 枚举里面有多少成员，以及成员的名字</li>
</ul>
<p>那么我们可以很轻松的拿到这些值：</p>
<pre><code class="language-rust">let ident = &amp;enum_struct.ident;
let variants_ident:Vec&lt;&amp;Ident&gt; = enum_struct.variants.iter().map(|variant| &amp;variant.ident).collect();
</code></pre>
<p>但是拿到这些值之后，我们的期望还不够，我们期望的是构建出以下的代码： </p>
<pre><code class="language-rust">impl BusinessError {
    pub fn get_http_code(&amp;self) -&gt; u16 {
        match self {
            BusinessError::InvalidEmail =&gt; 400,
            BusinessError::InvalidPassword =&gt; 400,
        }
    }
}
</code></pre>
<p>想比如手动拼 <code>TokenStream</code> ，<code>quote</code> 这个库提供了更加人性化的方式来生成<code>TokenStream</code>。我们可以通过以下的代码来生产我们期望的那个函数：</p>
<pre><code class="language-rust">let output = quote! {
    impl #ident {
        pub fn get_http_code(&amp;self) -&gt; u16 {
            match self {
                #(#ident::#variants_ident =&gt; 400,)*
            }
        }
    }
};
</code></pre>
<p>这里面一些 <code>quote</code> 特定的文法</p>
<ul>
<li><code>#VARIABLE</code> 可以访问到当前作用域下的同名变量</li>
<li><code>#(   )*</code> 用于展开循环</li>
</ul>
<p>自此，我们完成了<code>get_http_code</code>的方法实现。</p>
<h3>实现 <code>get_code</code> 方法</h3>
<p>在<code>get_http_code</code> 中我们了解了怎么输出一整个函数，对于 <code>get_code</code> 来说，每一个枚举分支类型返回的值都是不同的，这意味着我们在 <code>let variants_ident:Vec&lt;&amp;Ident&gt; = enum_struct.variants.iter().map(|variant| &amp;variant.ident).collect();</code> 这里就不能简单的拿到枚举成员的 <code>Ident</code> 了，我们需要在循环内构件出类似 <code>BusinessError::InvalidEmail =&gt; String::from(&quot;INVALID_EMAIL&quot;)</code> 这样的完整分支语句。这里其实也是很简单的。</p>
<pre><code class="language-rust">let code_fn_codegen:Vec&lt;proc_macro2::TokenStream&gt; = enum_struct.variants.iter().map(|variant| {
        let variant_ident = &amp;variant.ident;
        let content = inflector::cases::screamingsnakecase::to_screaming_snake_case(&amp;variant_ident.to_string());
        quote! {
            #ident::#variant_ident =&gt; String::from(content)
        }
    }).collect();
</code></pre>
<blockquote>
<ol>
<li>这里为了简单的演示效果，才用了 <code>inflector</code> 这个字符串格式转换库</li>
<li>这里用到了 <code>proc_macro2</code> 这个库，下文会讲为什么需要和其与<code>proc_macro</code>的区别</li>
</ol>
</blockquote>
<p>然后再拼凑 <code>get_code</code> 方法签名：</p>
<pre><code class="language-rust">pub fn get_code(&amp;self) -&gt; String {
    match self {
        #(#code_fn_codegen,)*
    }
}
</code></pre>
<p><code>get_message</code>的方法也是同样的道理这里就不重复描述了。</p>
<h3>从 <code>#[detail]</code> 中读取数据实现配置化</h3>
<p>对于每一个 Variant 的 attr 数据都会储存在 <code>attrs</code> 这个字段中。 <code>#[detail(code=400, message=&quot;this is an invalid password&quot;)]</code> 就会被格式化成以下的AST： (省略了很多没必要的字段)</p>
<pre><code class="language-rust">attrs: [
    Attribute {
        path: Path { segments: [ PathSegment { ident: Ident { ident: &quot;detail&quot;,}},],},
        tokens: TokenStream [
            Group {
                stream: TokenStream [
                    Ident { ident: &quot;code&quot;, },
                    Punct { ch: '=', },
                    Literal { lit: Lit { kind: Integer, symbol: &quot;400&quot; }},
                    Ident { ident: &quot;message&quot;, },
                    Punct { ch: '=', },
                    Literal { lit: Lit { kind: Str, symbol: &quot;this is an invalid password&quot; }},
                ],
            },
        ],
    },
],
</code></pre>
<p>可以看到 <code>code=400, message=&quot;this is an invalid password&quot;</code> 一样被格式化成了 <code>TokenStream</code> 。然而取数据出来也不是一件很简单的事情。所以为了解决这个问题，<code>darling</code> 应运而生，其借鉴了 <code>serde</code> 的思想，把<code>TokenStream</code> 反序列化成自定义的结构。</p>
<p>根据 <code>darling</code> 的写法，我们需要把我们期望的数据写成结构体：</p>
<pre><code class="language-rust">// derive FromDeriveInput, 表示这个结构体可以用 `syn::DeriveInput` 转换过来
#[derive(Debug, FromDeriveInput)]
// darling 自身的配置，接受 `detail` attr的数据，只允许 enum 的结构体，struct 报错。
#[darling(attributes(detail), supports(enum_any))]
struct DetailErrorEnum {
    // enum 的名称
    ident: syn::Ident,
    // enum 的枚举成员格式化成 DetailErrorVariant 
    data: darling::ast::Data&lt;DetailErrorVariant, darling::util::Ignored&gt;,
}

#[derive(Debug, FromVariant)]
#[darling(attributes(detail))]
struct DetailErrorVariant {
    ident: syn::Ident,
    // fields 的数据， 指的是 `InvalidEmail(String)` 里面的 `String`
    fields: darling::ast::Fields&lt;syn::Field&gt;,
    // 这里表示从 `FromMeta` 中取数据，这里特指 `#[detail(code=400)]`
    #[darling(default)]
    code: Option&lt;u16&gt;,
    // 这里表示从 `FromMeta` 中取数据，这里特指 `#[detail(message=&quot;detail message&quot;)]`
    #[darling(default)]
    message: Option&lt;String&gt;,
}
</code></pre>
<p>接着我们需要把 <code>proc_macro::TokenStream</code> 转换成 <code>proc_macro2::TokenStream</code> 再转换成 <code>syn::DeriveInput</code> 再转换成 <code>DetailErrorEnum</code></p>
<pre><code class="language-rust">let proc_macro2_token = proc_macro2::TokenStream::from(input);
let derive_input = syn::parse2::&lt;DeriveInput&gt;(input).unwrap();
let detail_error: DetailErrorEnum = DetailErrorEnum::from_derive_input(&amp;derive_input).unwrap();
</code></pre>
<p>通过<code>dbg!()</code> 可以看到反序列化之后的结果：</p>
<pre><code class="language-rust">[detail_error/src/lib.rs:39] &amp;detail_error = DetailErrorEnum {
    ident: Ident { ident: &quot;BusinessError&quot;, },
    data: Enum(
        [
            DetailErrorVariant {
                ident: Ident { ident: &quot;InvalidEmail&quot;, },
                fields: Fields { style: Unit, fields: [], },
                code: None,
                message: None,
            },
            DetailErrorVariant {
                ident: Ident { ident: &quot;InvalidPassword&quot;, },
                fields: Fields { style: Unit, fields: [], },
                code: Some( 500, ),
                message: Some(  &quot;this is an invalid password&quot;, ),
            },
        ],
    ),
}

</code></pre>
<p>这样的结果和过程都比直接操作 <code>TokenStream</code> 更加直观和可靠。</p>
<blockquote>
<p>但是至今我还不知道对于 <code>#[detail(code=400, message(&quot;password {} is invalid&quot;, p1))]</code> 这种 <code>message</code> 是<ruby>一组的数据<rp>(</rp><rt>group token stream</rt><rp>)</rp></ruby>怎么用 <code>darling</code> 来写</p>
</blockquote>
<p>这个时候就可以遍历 <code>detail_error.data[]</code> 来完成 <code>get_http_code </code>的 AST 生成</p>
<pre><code class="language-rust">let ident = &amp;detail_error.ident;
let variants = detail_error.data.take_enum().unwrap();
let http_code_fn_codegen: Vec&lt;proc_macro2::TokenStream&gt; = variants.iter().map(|variant| {
    let variant_ident = &amp;variant.ident;
    let http_code = variant.code.unwrap_or(400);
    quote! {
        #ident::#variant_ident =&gt; #http_code
    }
}).collect();
</code></pre>
<p>相比于之前的hardcode，现在我们在 5L 取出了在 <code>#[detail(code=500)]</code> 中的值。</p>
<p>同理 <code>get_message</code> 也可以用同样的方法生成：</p>
<pre><code class="language-rust">let message = variant.message.clone().unwrap_or_else(|| {
    inflector::cases::sentencecase::to_sentence_case(&amp;variant_ident.to_string())
});
</code></pre>
<p>自此整个 <code>BusinessError</code> 就用过程宏改造完成了。但是真实的业务还没有那么简单，举个例子说，对于认证错误(<code>AuthenticationError</code>)，通常需要返回具体的错误内容，这意味着 <code>message</code> 需要跟随着变化。也就是说真正的代码是长这个样子的：</p>
<pre><code class="language-rust">enum BusinessError {
    AuthenticationError(String)
}
fn get_message(&amp;self) {
    match self {
        BusinessError:AuthenticationError(p1) =&gt; format!(&quot;with detail {}&quot;, p1),
    }
}
</code></pre>
<p>那么我们之前的过程宏并不支持这样的特性，其实改造也很简单，在 darling 的 <code>DetailErrorVariant</code> 的 <code>fields</code> 里面就存有着 <code>String</code> 这个信息，那么我们只需要在循环体中构建出类似 <code>#ident::#variant_ident#fields =&gt; format!(#message, #fields)</code> 的语句即可。 感兴趣的读者可以试着让这个demo 支持该功能。</p>
<blockquote>
<p>在我的真实业务场景用使用 <code>#[detail(message=&quot;with detail {0}&quot;)]</code> 这样的方法来访问具体的字段的</p>
</blockquote>
<h2>关于过程宏的一些实践和认知</h2>
<h3><code>proc_macro</code> 和 <code>proc_macro2</code> 的区别</h3>
<p>前者是 rust 中为 过程宏库（在 <code>Cargo.toml</code> 中声明了 <code>#[lib] proc_macro=true</code>）中才能访问的特殊库， 而 <code>proc_macro2</code> 是与 <code>proc_macro</code> 基本一致，但是只是一个普通的库，所以 <code>syn</code> , <code>quote</code> , <code>darling</code> 这些都是建立在 <code>proc_macro2</code> 之上的， 所以在我们编写过程宏的时候基本上都是先把 <code>proc_macro::TokenStream</code> 转换成 <code>proc_macro2::TokenStream</code> 进行各种处理，最后才转换成 <code>proc_macro::TokenStream</code> 交回给 rustc。</p>
<h3>关于测试</h3>
<p>根据第一点的前提下，在转换成 <code>proc_macro2::TokenStream</code> 之后其实就跟过程宏没任何关系了，在抽象出一个独立的函数来处理和生成 <code>proc_macro2::TokenStream</code> ，我们就可以很轻松的对这个方法进行测试：</p>
<pre><code class="language-rust">#[proc_macro_derive(DetailError, attributes(detail))]
pub fn detail_error_fn(input: TokenStream) -&gt; TokenStream {
    handler(input.into()).into()
}

fn handler(input: proc_macro2::TokenStream) -&gt; proc_macro2::TokenStream {
    // real handler
}
</code></pre>
<p>简单来说，我们可以通过 <code>quote::quote!</code>来生成 <code>input</code> 对 <code>handler</code> 测试：</p>
<pre><code class="language-rust">#[test]
    fn it_works() {
        let input = quote! {...};
        let expected_output = quote! {...};
        let output = handler(input);
        assert_eq!(expected_output.to_string(), output.to_string());
    }
</code></pre>
<blockquote>
<p>7L 里面简单的用了 <code>to_string()</code> 来判断是否一致，导致输出的代码其实并没有带缩进，如果有需要可以用 <code>syn::visit</code>模块进行更加友善的结果输出。</p>
</blockquote>
<h3>用了过程宏之后，为什么就没有代码提示了</h3>
<p>这点很正常，因为<code>impl BusinessError {...}</code> 里面的内容是编译时生产的，确实是没有办法做到代码提示。试想下有了代码提示又跳转到哪里呢？</p>
<p>其实这个问题也不是无解的。通常的做法是建立一个 <code>Trait DetailError</code> 里面定义好我们需要的三个函数，然后再通过过程宏为 <code>BusinessError</code> 实现 <code>impl DetailError for Business {...}</code>。 这样代码提示和跳转就可以跳到 <code>DetailError</code>的定义里面去了。</p>
<p>为此我们需要把原来 <code>detail_error</code> 这个lib 改名成 <code>detail_error_macro</code> ，再创建一个新的lib 叫 <code>detail_error</code> 来定义 Trait <code>DetailError</code>。 </p>
<p>这点其实是 Rust 的限制，因为过程宏库无法再<ruby>暴露<rp>(</rp><rt>expose</rt><rp>)</rp></ruby>出其他的任何 Trait 和结构体。</p>
<h3>注意 ident 和非ident 的处理</h3>
<p><code>quote::quote!</code> 这个宏在处理 <code>String</code> 类型的时候会自动加上<code>&quot;</code> 形成 <code>&quot;content&quot;</code> ，正如数字类型会在后面追加具体的类型一样<code>400u16</code>。 所以如果通过<code>format!</code> 拼凑出一个 ident 之后需要用 <code>quote::format_ident!</code> 转换成 ident 类型，或者直接用 <code>format_ident! </code> 代替 <code>format!</code> 。</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>2019 个人总结</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/summaries-my-2019</link>
            
            <description><![CDATA[<p>无意中翻博客草稿的时候，发现了 2018 的总结还在停留在草稿阶段，现在就已经要写 2019 年度总结了，不禁感叹时间流逝之快。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/summaries-my-2019</guid>
            <pubDate>Tue, 31 Dec 2019 21:34:22 +0800</pubDate>
            <content:encoded><![CDATA[<p>无意中翻博客草稿的时候，发现了 2018 的总结还在停留在草稿阶段，现在就已经要写 2019 年度总结了，不禁感叹时间流逝之快。</p>
<!--more-->
<h2>R.I.P Python 2</h2>
<p>Python 2 停止维护，这绝对是一件所有 Pythonista 值得写入 2020 第一篇文章内的描述。我大概从2014年开始接触Python，但是就已经开始用 Python 3来写项目了。从 14 年到现在，除了写项目逻辑之外更多的时间是花费在 2 与 3 的兼容上面。虽然说 <code>six</code> 这种专门用来做兼容性库的存在极大的简化了兼容的实现，我还是十分希望能免去这些工作量。</p>
<p>一开始确实没有太大的理由和动力去做迁移工作，但是 Python 3 的一点点进步足以让迁移有足够的优势：Hash 算法的优化提升了部分性能；async 语法和 asyncio 生态的建立；type hint 的出现。这些让 Python 使用起来更加像一门现代化的语言。</p>
<p>时至今日，Python 2 的死去，是一件好事，摆脱了这么一个巨大的历史包袱，希望 Python 3 可以有更好的发展，搞搞 JIT，研究一下GIL。希望Python 3 越走越好。</p>
<p>另外 Guido 的退位也为 Python 带来了新的治理模式，不再是独裁者的所有物。<a href="https://github.com/pyhandle/hpy">hpy</a> 的出现也让 Python 有望存在一个标准的 spec，这样下来越来越多的更好的解析器有望可以涌现。</p>
<h2>OverWatch 赛事</h2>
<p>工作后对游戏的热爱就只能投放在赛事上。LOL 上 FPX 夺冠，Dota 里 大巴黎老干爹没能杀入决赛复仇 OG，这些都不是很关心。守望先锋在 2019 年的表现才是让人，让我无比兴奋的。</p>
<p>先是在世界杯上拿下亚军，再是在国内组出了 4 支俱乐部角逐 OWL 第二赛季的战场。同时 成都 Hunter 队的全华姿态也让国内对其抱有了极大的盼头。一是世界杯上中国队的超常发挥，二是对全华班的执着。听闻 Hunter 背后的老板跟 RNG 的老板还是同一个。从 OWL 第一赛季的「我们根本u知道怎么才能赢」到这个赛季的龙队获得第三赛段冠军，4支还是3支战队杀入季后赛这一切都在宣告着守望先锋在国内的蓬勃发展。正如林迟青说的那样「 We are ready to let the world know CHINA again」。</p>
<p>2020 年的第三赛季的主客场机制让不少 OWL 比赛在国内举行，相信氛围一定很好。可惜的事情是 Hunter 那位被誉为「神医」的主教练 RUI 因伤离队了，不知道成都队能不能在第三赛季保持水平的同时越战越勇。 </p>
<h2>坚定了 Rust 的路线</h2>
<p>在工作上写了一年 Java，虽说还是一如既往的讨厌它，但是毕竟是用来吃饭的本领，还是专研了一下，起码保证了自己的饭碗不会丢失。但是在业务的时间里面，更加坚定了3年前做的一个决定「学习 Rust」。</p>
<p>怎么说呢，前段时间看到一段文字可以很好的描述我对 Rust 的态度：</p>
<blockquote>
<p>大概五六月的时候我领着团队系统地学习了一下 Rust 语言，后来就有一搭没一搭的写点随手就扔的一次性代码。看到 Signal 的这篇文章后，我按捺不住心头的激情一一终于可以 用 Rust 做一个似乎有点什么用的工具了！写下来总体感觉，Rust 有可以媲美 ruby 的表现力，又有可以媲美 C++ 的性能（如果使用正确了），加上略逊于 haskell，但可以秒杀大部分主流语言的类型系统，使得用 rust 写代码是一种享受（除了编译速度慢）。这样一个 小工具200来行代码（包括单元测试，生成式测试以及一个简单的benchmark）就可以完 成，估计用 python, elixir 和 nodejs 都不那么容易达到。 </p>
</blockquote>
<p>大概就是这样，得益于过程宏等的一些生态，可以让代码写起来如同脚本语言那样的表现力和编写体验，既有极优秀的性能，还有完备的类型系统。这样 Rust 在各个领域都可以表现得很棒。</p>
<p>Rust 也让我真正的走上了 PL 的道路，之前的我可能是站在巨人肩膀上的，完全不知道脚下的巨人是谁，能干什么。但是 Rust 让我成功的走出了这一步。慢慢地了解到了类型系统及其图灵完备性，数理系统，逆变协变等等这些可能你日常都在使用，但是不知道其缘由和机理的事情。</p>
<p>我很庆幸在业务我不再是一个简单的CRUD boy，虽然我还有很长的一条路要走，但是起码我在2019迈出了那一步。很感谢 Rust 为我带来的这一个改变。</p>
<h2>Side Projects</h2>
<p>如同我在「技术断舍离」里面描述的那样，我开始不喜欢写同类型的项目，逐渐接触不同领域的东西。我开始认真地想做一个社区，希望能把 Resource.rs 给做好。我认真反思自己做过的东西，那些没能让我学习到的项目都是一次拖慢你节奏的过程。我注册了3min.work，寓意是「三分热度工作室」，我希望我的一些零时性的，阶段性的，实验性的作品或者尝试可以放在这里，让我有一个更加直观的感受，同时也不会阻止我的前进。</p>
<h2>最后</h2>
<p>一年来，虽说工作不如意，学习上没啥进步，也开始慢慢接受自己的平庸。但是我始终坚信着「勤能补拙」这个朴实的道理。</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>我的技术断离舍</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/learnning-zen-of-tech</link>
            
            <description><![CDATA[<p>在工作了一年多后，脑子里面满是想离职的事情。在此之前，我还在持续构思这一年多学习到内容的总结，然后品了品，这一年内，为了柴米油盐持续奔波，并没有留下过多的时间来学习新的技术，反而相比于刚刚毕业的那个时候，这时的我忘记的知识远远多于我学习到的。</p>
<p>然而又尽力过一段时间的沉思，我才意识到这可能并不是一件坏事，反而让我可以更好地学习下去。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/learnning-zen-of-tech</guid>
            <pubDate>Fri, 08 Nov 2019 16:52:13 +0800</pubDate>
            <content:encoded><![CDATA[<p>在工作了一年多后，脑子里面满是想离职的事情。在此之前，我还在持续构思这一年多学习到内容的总结，然后品了品，这一年内，为了柴米油盐持续奔波，并没有留下过多的时间来学习新的技术，反而相比于刚刚毕业的那个时候，这时的我忘记的知识远远多于我学习到的。</p>
<p>然而又尽力过一段时间的沉思，我才意识到这可能并不是一件坏事，反而让我可以更好地学习下去。</p>
<!--more-->
<h2>别让你练手的项目成为前进的阻碍</h2>
<p>大学阶段和刚工作时，我对造轮子有种极致的疯狂，面对各种奇奇怪怪的需求，我都希望通过自己的努力把它实现出来。我十分同意这确实很锻炼人。</p>
<p>为了研究 web 框架的原理，花了很大的精力看完了 flask tornado sanic 的 源码，自己造了一个 nougat 出来。看了 fastAPI 和 OpenAPI，写了一个能自动生成 swagger 信息的 flask 路由插件。为了不想用别人的 inline translator，自己写了一个极简的 Chrome 插件。为了管理 GitHub star，写了一个 Chrome 插件。等等这样的点子实在是太多太多了。</p>
<p>为了造轮子，同时找不到一样跟我有空又对这些项目感兴趣的前端劳动力，我于是决定学习前端。为此，我学了 React、Redux、Mbox 等这些现代的前端框架，又去折腾了 PWA，甚至还学了 React-Native 只是为了想把这些想法迁移到 IOS 或者安卓上。</p>
<p>这些经历看着属实很奇妙也很有意思，然而在此之后随之而来的便是各种维护噩梦。</p>
<p>WEB 框架 nougat 有人尝试使用了，也给了很多诸如「为什么你这个框架没有 CLI 控制能力」、「为什么别的框架写某某功能很舒服，然而你这个就那么难受」。于是我踏上了一条「重构-修BUG」的恶性循环之路，为了实现这些功能或者修复某个缺陷，导致了我需要花大量的时间投入在上面，甚者为了修复某些BUG需要把整个框架重构大部分。这显然不是我希望看到的，这个框架不是为了让别人使用而出现的，而是我的一个熟悉底层的过程。</p>
<p>这样占用大量时间的维护工作占用了我大量的业余学习时间。于是我做了一个很大的改变「我做的项目只为了解决我自己的需求」，在这样的前提下，我拒掉了大量的维护工作，让我可以更加轻松地投入到那些我不懂而又十分感兴趣的领域。</p>
<h2>技术的世界里没有「银弹」</h2>
<p>要时刻在脑子里面保留着一个概念就是「银弹不可能有。如果有，那你肯定被骗了」。</p>
<p>在大学后半段开始，我做了一个赌我以后职业之旅的决定「我要以 Rust 为我的主导编程语言」。现在看来，Rust 确实在慢慢火起来。但是当时的我，或者说是从开始工作没多久，我对 Rust 有种莫名的崇拜和狂热，希望什么都用 Rust 来实现，无论是能用 shell 实现的脚本，还是用根本还没成熟的 WASM 来写网页前端。</p>
<p>Rust 确实很强大，这点毋庸置疑。能做与擅长，是两件截然不同的事情。我就是把这两件事情混在了一起。为了用 WASM 写前端，我看了很多所谓的框架，实际上都是一个很简单的雏型。花了几十倍的消耗终于写出了一个性能提升无关的前端。</p>
<p>看似很有成就感的事情，仔细思考下来实则不然。写了那么多都还只是停留在调用他人框架的阶段，并没有真正地去了解框架的构造和执行原理，甚至没有去了解 WASM 的原理。相比于写逻辑，后者的知识才是更加值得研究的。</p>
<p>在意识到了这点之后，我慢慢的形成了语言只是一种工具，在合适的场景使用合适的语言才是一个成熟的表现。相比于用 Rust 来写机器学习，这种看着就不可能的事情其实很容易分辨，难就难在那些两者都表现出「我可以」的场景下。</p>
<p>快速成型、脚本工作就使用 Python；CLI 解析、网络代理处理等就用 Rust；网页前端使用 React。 </p>
<p>银弹可能不存在，但是一把装满了不同「银弹」的手枪是可能存在的。</p>
<h2>多刷文档，别重复工作</h2>
<p>当擅长一门技术之后，就很容易成迷其中，希望写出很多所谓的作品出来表现自己，殊不知其实这些作品都只是表现出你单独一门技术的能力。</p>
<p>这段时间我就是陷入了这样的困境中，因为自己是擅长 WEB 方向的，同时在熟练使用 actix 之后，脑子里面都是做些什么作品出来。左想右想确实想出了很多，不少也事件出来了，但是都是基于 actix 这个 web 框架的，而且大部分工作都是在「写数据库模型 - CURD」的循环中。</p>
<p>看似做出了很多有意思的项目，实际上是「业务」，那些东西并没有脱离出那一个特定的技术。</p>
<p>同时长时间在业务层工作，会形成一种「知其然，不知其所以然」的困境。比如现在我都没搞太懂 actix 到底是怎么跑的，为什么他能做到碾压性的性能压制。</p>
<p>在这时，我才意识到了自己在底层认知的缺陷。长时间活跃在业务层，缺少了对实现层的了解。为此，如上述所说，我放弃维护了大部分的项目，把这些时间投入到了 RFC 等文档的阅读中。特别是在 Rust 领域里面，单纯的写 Rust 代码 和阅读 Rust RFC 的发展、参与对某个实现的讨论的感觉是完全不一样的。这也让我了解到了更多 PL 领域的内容。</p>
<p>同时在深入了解底层知识后，才深刻体会到语言只是一种工具的感觉。在工作之前，我都以 Python 和 Rust 为主，然而工作确实以 Java 为主，在没有过多的 Java 基础下，通过对底层抽象的了解，可以在工作中不至于出现什么问题。</p>
<p>在抛弃掉大量相似的项目后，反而有了更多的时间去了解其他领域的知识，这无论是在深度和广度都十分有用。</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>简单几步打造个人集群和自动化流水线</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/personal-docker-cluster-and-ci-package-pipeline</link>
            
            <description><![CDATA[<p>在认识的小伙伴发了他做的项目部署文档出来之后，我便决定开始写这篇文章，原因是他使用的部署方式太麻烦，而且太不自动化，同时有时候也会因为开发任务繁忙导致没能部署好等等。</p>
<p>这篇文章是介绍了一个极度适合用于个人或者几个人的小团队使用的集群搭建方式，在保证了安全性的同时，提供了几乎全自动的部署方式，在手动配置一次之后，每次服务更新都是自动触发的，极大地减少了部署的时间。</p>
<p>本篇文章适用于 GIT-FLOW 类似的「master 即 生产代码」的一切工作模式（或者某一个分支为生产代码）。如果您的开发模式不符合这个特征，那么可以关闭网页了。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/personal-docker-cluster-and-ci-package-pipeline</guid>
            <pubDate>Thu, 13 Jun 2019 13:16:33 +0800</pubDate>
            <content:encoded><![CDATA[<p>在认识的小伙伴发了他做的项目部署文档出来之后，我便决定开始写这篇文章，原因是他使用的部署方式太麻烦，而且太不自动化，同时有时候也会因为开发任务繁忙导致没能部署好等等。</p>
<p>这篇文章是介绍了一个极度适合用于个人或者几个人的小团队使用的集群搭建方式，在保证了安全性的同时，提供了几乎全自动的部署方式，在手动配置一次之后，每次服务更新都是自动触发的，极大地减少了部署的时间。</p>
<p>本篇文章适用于 GIT-FLOW 类似的「master 即 生产代码」的一切工作模式（或者某一个分支为生产代码）。如果您的开发模式不符合这个特征，那么可以关闭网页了。</p>
<!--more-->
<h2>服务器架构</h2>
<p>服务器方面，为了方便使用，我们选择了 docker swarm 而不是 k8s，我们先看一个全览图：</p>
<p><img src="https://i.loli.net/2019/06/13/5d0220558718054830.jpg" alt="server-structure.jpg" /></p>
<p>整个架构的思路就是用 NGINX 来代理所有的 web 应用，内部每个应用都以 stack 的方式部署，同时配合 Portainer 进行自动化更新。一个超级简单的部署模式，却基本满足了我个人的所有开发场景。</p>
<h2>环境部署</h2>
<p>首先你要有一台独立的服务器，什么发行版都不所谓了，我们不会在宿主机里面干任何事情，一切都是在Docker 内实现。</p>
<p>服务器只需要对外暴露 80 和 443 端口即可，ssh 使用密钥的方式登陆保证安全。</p>
<h3>安装Docker 并启动 Docker Swarm 模式</h3>
<p>因为这里采用了单机的方式，所以一步就启动了 swarm 模式：</p>
<pre><code class="language-shell">docker swarm init
</code></pre>
<h3>安装 Nginx</h3>
<p>在这里 Nginx 作为 Load Balancer 和自动 HTTPS 的工具，需要实现服务发现的功能，你可以用 <code>docker-gen</code> 自己撸一个，也可以采用现成的软件来完成。这里我才用了这个 <a href="https://github.com/buchdag/letsencrypt-nginx-proxy-companion-compose/blob/master/2-containers/compose-v3/environment/docker-compose.yaml">buchdag/letsencrypt-nginx-proxy-companion-compose</a> 。</p>
<p>先创建一个 nginx network：</p>
<pre><code class="language-shell">docker network create nginx-net --attachable
</code></pre>
<p>因为我喜欢吧 volume 不与任何服务直接挂钩，所以我的 volume 都是独立创建的：</p>
<pre><code class="language-shell">docker volume create nginx-conf
docker volume create nginx-vhost
docker volume create nginx-html
docker volume create nginx-dhparam
docker volume create nginx-certs
</code></pre>
<p>最后以 stack 的模式启动 nginx: </p>
<pre><code class="language-yaml">version: '3'

services:

  nginx-proxy:
    image: jwilder/nginx-proxy
    ports:
      - &quot;80:80&quot;
      - &quot;443:443&quot;
    volumes:
      - nginx-conf:/etc/nginx/conf.d
      - nginx-vhost:/etc/nginx/vhost.d
      - nginx-html:/usr/share/nginx/html
      - nginx-dhparam:/etc/nginx/dhparam
      - nginx-certs:/etc/nginx/certs:ro
      - /var/run/docker.sock:/tmp/docker.sock:ro
    labels:
      - &quot;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy&quot;
    networks:
      - nginx-net

  letsencrypt:
    image: jrcs/letsencrypt-nginx-proxy-companion
    depends_on:
      - nginx-proxy
    volumes:
      - nginx-vhost:/etc/nginx/vhost.d
      - nginx-html:/usr/share/nginx/html
      - nginx-dhparam:/etc/nginx/dhparam:ro
      - nginx-certs:/etc/nginx/certs
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - nginx-net

volumes:
  nginx-conf:
    external:
      name: nginx-conf
  nginx-vhost:
    external:
      name: nginx-vhost
  nginx-html:
    external:
      name: nginx-html
  nginx-dhparam:
    external:
      name: nginx-dhparam
  nginx-certs:
    external:
      name: nginx-certs

networks:
  nginx-net:
    external: true
</code></pre>
<pre><code class="language-shell">docker stack deploy --compose-file nginx.yml nginx
</code></pre>
<p>OK，这个时候 nginx 就已经创建好了。</p>
<h3>安装 Portainer</h3>
<p>Portainer 是一个为数不多的简洁，消耗资源又少的 docker 管理面板，有他可以更加直观地管理集群的内容，同时新版的 Portainer 还提供了一个比较方便的更新服务的方法，所以他对于我来说是必须的</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  agent:
    image: portainer/agent
    environment:
      # REQUIRED: Should be equal to the service name prefixed by &quot;tasks.&quot; when
      # deployed inside an overlay network
      AGENT_CLUSTER_ADDR: tasks.agent
      # AGENT_PORT: 9001
      # LOG_LEVEL: debug
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/volumes:/var/lib/docker/volumes
    networks:
      - agent_network
    deploy:
      mode: global
      placement:
        constraints: [node.platform.os == linux]

  portainer:
    image: portainer/portainer
    command: -H tcp://tasks.agent:9001 --tlsskipverify
    environment:
      VIRTUAL_HOST: portainer.kilerd.me
      VIRTUAL_PORT: 9000
      LETSENCRYPT_HOST: portainer.kilerd.me
      LETSENCRYPT_EMAIL: blove694@gmail.com
    volumes:
      - portainer_data:/data
    networks:
      - agent_network
      - nginx-net
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints: [node.role == manager]

networks:
  agent_network:
    driver: overlay
  nginx-net:
    external: true

volumes:
  portainer_data:
</code></pre>
<p><strong>注意：这里不能直接照抄配置文件了</strong>：在 <code>portainer</code> 这个服务里面，对外暴露出了一个GUI管理页面，他是需要通过 nginx 进行代理才能访问的，所以需要修改 <code>VIRTUAL_HOST</code> <code>LETSENCRYPT_HOST</code> 为你的域名， <code>LETSENCRYPT_EMAIL</code> 为你的邮箱。</p>
<pre><code class="language-shell">docker stack deploy --compose-file portainer.yml portainer
</code></pre>
<p>好，不出意外的话，你就可以通过 <code>https://你的域名</code> 来访问到 Portainer 的页面了，进去改密码，就完事了。</p>
<h3>部署自己的 Docker Registry</h3>
<p>首先先创建 volumes：</p>
<pre><code class="language-shell">docker volume create registry_data
docker volume create registry_auth
</code></pre>
<p>然后在 <code>registry_auth</code> 生成一个用于提供密码保护的配置文件 <code>.passwd</code> ，因为 registry 没有密码很不安全</p>
<pre><code class="language-shell">cd /var/lib/docker/volumes/registry_auth/_data
docker run --entrypoint htpasswd registry:2 -Bbn 用户名 密码 &gt; .passwd
</code></pre>
<p><strong>上述不要直接复制，请修改用户名密码</strong></p>
<p>然后，部署 stack：</p>
<pre><code>version: &quot;3&quot;
services:
  registry:
    image: registry:2
    environment:
      VIRTUAL_HOST: registry.kilerd.me
      VIRTUAL_PORT: 5000
      LETSENCRYPT_HOST: registry.kilerd.me
      LETSENCRYPT_EMAIL: blove694@gmail.com
      REGISTRY_AUTH: htpasswd
      REGISTRY_AUTH_HTPASSWD_PATH: /auth/.passwd
      REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm
    volumes:
      - registry_data:/var/lib/registry
      - registry_auth:/auth
    networks:
      - nginx-net
volumes:
  registry_auth:
    external:
      name: registry_auth
  registry_data:
    external:
      name: registry_data

networks:
  nginx-net:
    external: true

</code></pre>
<p><strong>上述不要直接复制，请修改访问地址，邮箱</strong></p>
<p>因为 nginx 有默认最大传输大小，所以可能会导致<code>docker push image</code> 失败，在 image 太大时，所以需要一下命令取消限制：</p>
<pre><code class="language-shell">cd /var/lib/docker/volumes/nginx-vhost/_data
echo &quot;client_max_body_size 0;&quot; &gt; registry.kilerd.me
</code></pre>
<p><strong>上述不要直接复制，请修改域名</strong></p>
<p>这样必要的东西就完成了，环境就完全搭建完毕。</p>
<h2>自动化流水线</h2>
<p>接下来就是怎么通过流水线自动发布新版本的应用了，这里会以我的一个小项目为例子，一一说明你需要怎么做。</p>
<p>假设我们的项目就是一个简单的文本：</p>
<pre><code class="language-shell">echo &quot;hello world&quot; &gt; index.html
</code></pre>
<p>然后我们编写一个超级简单的 Dockerfile：</p>
<pre><code class="language-dockerfile">FROM python:3.7

COPY index.html index.html

EXPOSE 8000
CMD [&quot;python -m http.server 8000&quot;]
</code></pre>
<p>这个docker 会暴露出 8000 端口作为 http 访问。</p>
<h3>Travis CI or Circle CI</h3>
<p>相比自己搭建一套CI，我现在了 Circle CI 来做持续集成和持续部署。我们的策略是这样的：</p>
<ul>
<li>如果不是 master 分支，不执行</li>
<li>打包docker 镜像</li>
<li>推送到我们刚刚部署的 Registry</li>
<li>更新我们的服务</li>
</ul>
<p>先看看 circle ci 的配置文件：</p>
<pre><code class="language-yaml">version: 2
jobs:
  build:
    working_directory: /app
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - restore_cache:
          keys:
            - v1-{{ .Branch }}
          paths:
            - /caches/app.tar
      - run:
          name: Load Docker image layer cache
          command: |
            set +o pipefail
            docker load -i /caches/app.tar | true
      - run:
          name: Build application Docker image
          command: |
            docker build --cache-from=app -t app .
      - run:
          name: Save Docker image layer cache
          command: |
            mkdir -p /caches
            docker save -o /caches/app.tar app
      - save_cache:
          key: v1-{{ .Branch }}-{{ epoch }}
          paths:
            - /caches/app.tar
      - run:
          name: Push to registry
          command: |
            docker login registry.kilerd.me -u 用户名 -p 密码
            docker tag app registry.kilerd.me/app
            docker push registry.kilerd.me/app
  deploy:
    machine:
      enabled: true
    steps:
      - run:
          name: update service
          command: |
            curl -X POST PORTAINER_WEBHOOK_URL
workflows:
  version: 2
  build-and-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: master
</code></pre>
<p>上面这个配置信息很多都是与缓存有关的，用来加快<code>docker build </code> 的过程，主要的只有几行：</p>
<ul>
<li><code>docker login registry.kilerd.me -u 用户名 -p 密码</code> 登陆部署的 Registry</li>
<li><code>docker tag app registry.kilerd.me/app</code> 打 TAG</li>
<li><code>docker push registry.kilerd.me/app</code> 推送</li>
<li><code>curl -X POST PORTAINER_WEBHOOK_URL</code> 更新服务，这里因为还没有在集群里面创建 stack，所以还没有这个 <code>PORTAINER_WEBHOOK_URL</code> ，下文会补上。</li>
</ul>
<p><strong>注意：上述用户名、密码、PORTAINER_WEBHOOK_URL 请用 circle 的 environment variable 来储存，不要直接写在配置文件内</strong> （作者就吃了这样的亏，导致项目无法开源）</p>
<p>OK，推到项目仓库，circle ci 就开始执行了，配置没问题的话， registry 里面就已经有这个application 的 docker 镜像了，但是更新会失败，因为我们还没有创建application的stack。</p>
<h3>Application Stack</h3>
<p>对于一个应用我们都要创建一个独立的stack，并接入 <code>nginx-net</code> 让 nginx 为应用代理http，同时申请 https 证书。</p>
<p>那么这个应用的 stack 文件要这么写：</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  backend:
    image: registry.kilerd.me/app:latest
    environment:
      VIRTUAL_HOST: test.kilerd.me
      VIRTUAL_PORT: 8000
      LETSENCRYPT_HOST: test.kilerd.me
      LETSENCRYPT_EMAIL: blove694@gmail.com
    networks:
      - nginx-net

networks:
  nginx-net:
    external: true
  backend:
</code></pre>
<p><strong>上述配置文件不要直接复制，请修改 镜像地址，域名，邮箱</strong></p>
<p>创建 stack，之后我们就去要去找到刚刚缺失的那个 <code>PORTAINER_WEBHOOK_URL</code> </p>
<p><img src="https://i.loli.net/2019/06/13/5d024996dc34d88705.png" alt="Screen Shot 2019-06-13 at 9.01.43 PM.png" /></p>
<p>进入你想更新的那个 Service Detail 页面，开启 <code>Service webhook</code> 功能，链接就出来了，把它复制到circle的配置中。</p>
<p>一切就完成了。</p>
<h3>开发流程</h3>
<p>如果你的开发流程是基于 GIT-FLOW 的话，那么可以 follow 一下步骤进行开发 ：</p>
<ul>
<li>在 <code>feature/xxx</code> 分支开发对于 Feature</li>
<li>开发完成进入 <code>develop</code> 分支进行验证</li>
<li>release version 阶段把 <code>develop</code> 合并进 <code>master</code> 分支</li>
<li>Circle CI 收到 <code>master</code> 分支的推送 webhook， 触发docker image 构建</li>
<li>构建完成，推送 image 到 registry</li>
<li>推送完成，通过 <code>PORTAINER_WEBHOOK_URL</code> 触发 Portainer 更新指定的 Service</li>
</ul>
<blockquote>
<p>docker service update xxx 一直都有个问题，不会主动拉取latest的镜像，portainer 自带的这个可以满足，所以说在我的开发环境里面他是必须的。比如就只能 ssh 到服务器，手动执行命令更新。</p>
</blockquote>
<p>所以在开发阶段，只要开发然后推送，其他都由 CI 帮你完成所有的部署功能。</p>
<h2>缺点和优化的地方</h2>
<ul>
<li>这个部署方式只适用于单机 docker swarm 集群，多机需要用 NAS 来创建 volume</li>
<li>如果打包出来的docker image 无法执行，没有一个有效的回退旧版本机制</li>
<li>目前没有找到比较好的日志收集方式</li>
</ul>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>Actix通过什么方法来实现路由注册的.RUST</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/rust-how-actix-register-route-in-rust</link>
            
            <description><![CDATA[<p>如果你写过 <code>actix-web</code> 1.0 的代码，会发现在路由注册的函数中，你可以传入各种不同签名的函数题。</p>
<pre><code class="language-rust">App::new()
        .service(
            web::scope(&quot;/admin/&quot;)
                .service(
                    web::resource(&quot;/article&quot;).route(
                        web::post().to(post_method),
                        web::delete().to(delete_method)
                    ),
                )
</code></pre>
<p>不难发现，根据业务的不同，传入 <code>to</code> 方法中的函数签名必然会不同，那么 Actix 是怎么处理的呢？或者说是怎么实现这个功能的。接下来我们将一步一步实现这一个类似的需求。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/rust-how-actix-register-route-in-rust</guid>
            <pubDate>Mon, 13 May 2019 08:40:47 +0800</pubDate>
            <content:encoded><![CDATA[<p>如果你写过 <code>actix-web</code> 1.0 的代码，会发现在路由注册的函数中，你可以传入各种不同签名的函数题。</p>
<pre><code class="language-rust">App::new()
        .service(
            web::scope(&quot;/admin/&quot;)
                .service(
                    web::resource(&quot;/article&quot;).route(
                        web::post().to(post_method),
                        web::delete().to(delete_method)
                    ),
                )
</code></pre>
<p>不难发现，根据业务的不同，传入 <code>to</code> 方法中的函数签名必然会不同，那么 Actix 是怎么处理的呢？或者说是怎么实现这个功能的。接下来我们将一步一步实现这一个类似的需求。</p>
<!--more-->
<h2>最小的执行框架</h2>
<p>为了实现这个功能，我们先模拟出一个最小的框架：有一个路由 <code>Router</code> 他里面有一个方法 <code>to</code> 来注册 handler，为了方便同时关注我们所想的，handler 这里就设计成只能返回 <code>String</code>。</p>
<pre><code class="language-rust">#[derive(Debug)]
enum Method {
    Head,
    Option,
    Get,
    Post,
    Patch,
    Put,
    Delete,
}

struct Router;

impl Router {
    pub fn to&lt;H&gt;(&amp;self, method: Method, handler: H) -&gt; &amp;Self
    where
        H: Fn() -&gt; String,
    {
        println!(&quot;handle route {:?}&quot;, method);
        self
    }
}

fn public_route() -&gt; String {
    &quot;hello world&quot;.into()
}

fn main() {
    let router = Router {};
    router.to(Method::Get, public_route);
}

</code></pre>
<p>代码：https://gist.github.com/8c8c8ad0dbe21d0ebacc8d9f6f5f5c78</p>
<p>在这个演示代码中 17L，限定了传入的 handler 只能是 <code>Fn()-&gt;String</code>，意思是没有参数，同时返回值为 <code>String</code></p>
<h2>允许传入不同参数</h2>
<p>Rocket 和 Actix 都不约而同的采用了 Request Guard 的方式来对路由进行限制或者扩展，有一个例子是说，如果我们希望一个路由只有授权之后才能访问，那么这个 Handler 是这样签名的：</p>
<pre><code class="language-rust">fn private_route(token: Token) -&gt; String {
    &quot;hello private world&quot;.into()
}
</code></pre>
<p>当我们注册到 <code>Router</code> 时，必然需要调用 <code>to</code> 方法，<code>router.to(method::Post, private_route)</code> ，那会出现一下的错误</p>
<pre><code>error[E0593]: function is expected to take 0 arguments, but it takes 1 argument
  --&gt; src/main.rs:37:6
   |
29 | fn private_route(token: Token) -&gt; String {
   | ---------------------------------------- takes 1 argument
...
37 |     .to(Method::Post, private_route);
   |      ^^ expected function that takes 0 arguments

error: aborting due to previous error
</code></pre>
<p>错误原因是说 <code>to</code> 里面的 handler 范型约束了不能带参数，而 Rust 又不能写出类似 <code>where H: Fn() -&gt; String | Fn(Token) -&gt; String</code> 的或关系的骚操作，所以只能把这些关系再抽象一层，于是就抽象出了 Trait <code>HandlerFactory</code>。 这个 Trait 只是把不同的handler 包装成相似的签名。</p>
<pre><code class="language-rust">trait HandlerFactory&lt;P&gt; {
    fn call(&amp;self, _: P) -&gt; String;
}
</code></pre>
<p>这下我们就可以通过 <code>handler.call()</code> 来执行这些 handler。</p>
<p>同时，我们对刚刚这两个Handler 实现一下这个 Trait <code>HandlerFactory</code></p>
<pre><code class="language-rust">impl&lt;F&gt; HandlerFactory&lt;()&gt; for F where F: Fn() -&gt; String {
    fn call(&amp;self, _: ()) -&gt; String {
        (self)()
    }
}

impl&lt;F&gt; HandlerFactory&lt;(Token, )&gt; for F
    where F: Fn(Token) -&gt; String,
{
    fn call(&amp;self, params: (Token, )) -&gt; String {
        (self)(params.0)
    }
}
</code></pre>
<p>顺便再改一下 <code>to</code> 的签名，让 <code>to</code> 接受 <code>HandlerFactory</code> 的类型就可以把刚刚的两个handler 都通过 <code>to</code>方法来注册了。</p>
<p>详情代码看这里：https://gist.github.com/3b166bc90bd6ee6dcb20d3b1f751e119</p>
<h2>FromRequest 的抽象</h2>
<p>在第二个handler 里面，我们传入了<code>Token</code> 类型的参数，同时用了 <code>impl&lt;F&gt; HandlerFactory&lt;(Token, )&gt; for Fwhere F: Fn(Token) -&gt; String</code> 来注册签名，那么如果我们有大量不同类型的参数的话，是不是都要一个一个明确的写出声明呢？其实不然，我们可以给这些类型共同实现一个叫 <code>FromRequest</code> 的Trait，来统一处理。</p>
<pre><code class="language-rust">trait FromRequest {
    fn from_request() -&gt; Self where Self: Sized;
}
</code></pre>
<p>在 <code>impl FromRequest for Token</code>, <code>impl FormRequest for String</code> ... 的方法实现之后，Router 知道这是一个「实现了 <code>FromRequest</code> Trait 」的类型就可以了。意味着在 <code>to</code> 的签名里面可以换成 Trait 的名字，而不是某种具体的类型。又因为我们需要告诉 <code>HandlerFactory</code> 这些参数的具体类型，所以需要在其加多一个范型参数。</p>
<pre><code class="language-rust">trait HandlerFactory&lt;P&gt; {
    fn call(&amp;self, _: P) -&gt; String;
}
</code></pre>
<p>再看看对单个参数的实现</p>
<pre><code>impl&lt;F, P&gt; HandlerFactory&lt;(P, )&gt; for F
    where F: Fn(P) -&gt; String,
          P: FromRequest
{
    fn call(&amp;self, params: (P, )) -&gt; String {
        (self)(params.0)
    }
}
</code></pre>
<p>在 3L 我们明确地指出 P 需要是实现了 <code>FromRequest</code> 的 类型。 好，需求就实现了，具体实现在<a href="https://gist.github.com/4ee6eb1e3dda0f6e7c8858a1c58026ed">这里</a></p>
<h2>多个参数怎么办</h2>
<p>handler 里面不可能永远都只有一个参数吧。再看看上面的那个代码，我们在 <code>HandlerFactory&lt;(P, )&gt; </code> 其实是传入了一个 Tuple，里面只有一个值，类型是 P，同时 P 还是 FromRequest 的类型。 </p>
<p>那是不是意味着只要我们有一个 <code>HandlerFactory&lt;(P, P2)&gt; </code> 的实现就可以完成两个参数的传入了呢？没错就是这样，所以我们可以写下以下的代码：</p>
<pre><code class="language-rust">impl&lt;F, P, P2&gt; HandlerFactory&lt;(P, P2)&gt; for F
    where F: Fn(P, P2) -&gt; String,
          P: FromRequest,
          P2: FromRequest
{
    fn call(&amp;self, params: (P, P2)) -&gt; String {
        (self)(params.0, params.1)
    }
}
</code></pre>
<p>那三个参数呢？四个参数呢？五个呢？以此往下，是需要重复写大量的 <code>impl </code>代码的。但是有一个问题是，对于不同的参数，它的函数签名又不一样，不能用「为某种类型实现某种 Trait」的方式一次性写完。但是又不想写那么多重复的代码怎么办？</p>
<p>在详细看看一个参数的签名和两个参数的签名，其实只有几个地方不一样，而且大致都能复用，那么这时候宏的作用就出来了。这里我从 actix 模仿了一个出来。</p>
<pre><code class="language-rust">macro_rules! factory_tuple ({ $(($n:tt, $T:ident)),+} =&gt; {
    impl&lt;F, $($T,)+&gt; HandlerFactory&lt;($($T,)+)&gt; for F
    where F: Fn($($T,)+) -&gt; String,
    {
        fn call(&amp;self, param: ($($T,)+)) -&gt; String {
            (self)($(param.$n,)+)
        }
    }
});
</code></pre>
<p>这里 Actix 的源码在<a href="https://github.com/actix/actix-web/blob/df08baf67f166d2d75118b859f1049b01944daf4/src/handler.rs#L376">src/handler.rs#L376</a></p>
<p>关于 Rust 宏的签名可以通过<a href="https://lukaslueg.github.io/macro_railroad_wasm_demo/">这个网站</a>来查看它的签名。</p>
<p>那么我们在实现不同参数的时候就可以通过以下简单的代码来简单实现：</p>
<pre><code class="language-rust">factory_tuple!((0, A));
factory_tuple!((0, A), (1, B));
factory_tuple!((0, A), (1, B), (2, C));
</code></pre>
<p>对于三个参数的宏实现，展开之后是这个样子的：</p>
<pre><code class="language-rust">impl&lt;F, A, B, C, &gt; HandlerFactory&lt;(A, B, C, )&gt; for F
    where F: Fn(A, B, C ) -&gt; String,
{
    fn call(&amp;self, param: (A, B, C, )) -&gt; String {
        (self)(param.0, param.1, param.2 )
    }
}
</code></pre>
<p>具体代码可以<a href="https://gist.github.com/7610290a37934703a4450888afb54f2f">看看这里</a></p>
<h2>最后</h2>
<p>这个场景确实是很常见的，这里用了以下几个特性来实现了这个功能：</p>
<ul>
<li>为某种类型实现Trait</li>
<li>为「实现了某种Trait」的类型实现Trait</li>
<li>利用宏消除重复代码</li>
</ul>
<h3>彩蛋</h3>
<p>看回 <a href="https://github.com/actix/actix-web/blob/df08baf67f166d2d75118b859f1049b01944daf4/src/handler.rs#L411">acitx-web handler</a> 的实现，它只实现到了10个参数，那是不是说只要写出 11 个参数的 handler 就会报错呢？我们感觉来试一下。</p>
<pre><code class="language-rust">
use actix_web::{web, App, HttpServer, Responder};

fn a_lot_parameters(
    a: web::Path&lt;String&gt;,
    b: web::Path&lt;String&gt;,
    c: web::Path&lt;String&gt;,
    d: web::Path&lt;String&gt;,
    e: web::Path&lt;String&gt;,
    f: web::Path&lt;String&gt;,
    g: web::Path&lt;String&gt;,
    h: web::Path&lt;String&gt;,
    i: web::Path&lt;String&gt;,
    j: web::Path&lt;String&gt;,
    //    k: web::Path&lt;String&gt;,
    //    l: web::Path&lt;String&gt;,
    //    m: web::Path&lt;String&gt;,
) -&gt; impl Responder {
    &quot;hello world&quot;
}

fn main() {
    HttpServer::new(move || {
        App::new().route(
            &quot;/{a}/{b}/{c}/{d}/{e}/{f}/{g}/{h}/{i}/{j}/{k}/{l}/{m}&quot;,
            web::get().to(a_lot_parameters),
        )
    })
    .bind((&quot;0.0.0.0&quot;, 8000))
    .unwrap()
    .run();
}
</code></pre>
<p>10个的情况正常启动了项目。好我们吧注释去掉一个，再启动看看会不会报错</p>
<pre><code>error[E0277]: the trait bound `fn(actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;) -&gt; impl actix_web::responder::Responder {a_lot_parameters}: actix_web::handler::Factory&lt;_, _&gt;` is not satisfied
   --&gt; src/main.rs:121:24
    |
121 |             web::get().to(a_lot_parameters),
    |                        ^^ the trait `actix_web::handler::Factory&lt;_, _&gt;` is not implemented for `fn(actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;, actix_web::types::path::Path&lt;std::string::String&gt;) -&gt; impl actix_web::responder::Responder {a_lot_parameters}`

error: aborting due to previous error
</code></pre>
<p>YEAH，预期地报错了✌️</p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>优化 Rust 的项目 Docker 打包流程.Rust</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/rust-auto-optimize-dockerize-procedure</link>
            
            <description><![CDATA[<p>在把 Project Rubble 从 Rocket 框架迁移到 Actix-web 的过程中，我顺便把困惑已久的 Docker 打包流程优化了不少。</p>
<p>这篇文章适用于那些在项目中带有 <code>Denpendencies.lock</code> 类似的固定依赖版本的 LOCK 文件。</p>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/rust-auto-optimize-dockerize-procedure</guid>
            <pubDate>Sun, 28 Apr 2019 15:52:05 +0800</pubDate>
            <content:encoded><![CDATA[<p>在把 Project Rubble 从 Rocket 框架迁移到 Actix-web 的过程中，我顺便把困惑已久的 Docker 打包流程优化了不少。</p>
<p>这篇文章适用于那些在项目中带有 <code>Denpendencies.lock</code> 类似的固定依赖版本的 LOCK 文件。</p>
<!--more-->
<p>一般的构建流程可以分为以下几个步骤：<strong>拉取最新代码</strong> -&gt; <strong>构建</strong> -&gt; <strong>打包</strong> 。拉取代码一般都交由 CI 来完成。下文会着重讲我是怎么优化构建流程的，同时我会依照 Project Rubble 来做真实场景说明，技术栈如下： <code>Rust + Travis CI</code></p>
<h2>什么都自己编译</h2>
<pre><code class="language-dockerfile">FROM rust:1.29
RUN cargo install diesel_cli --no-default-features --features postgres
EXPOSE 8000
COPY . /app
WORKDIR /app
RUN cargo build --release
ENTRYPOINT [&quot;sh&quot;, &quot;./entrypoint.sh&quot;] 
</code></pre>
<p>这个阶段我们只考虑「如何把项目打包出 docker 的镜像」，所以在这个 Dockerfile 中 有两个超级耗时的命令：</p>
<ul>
<li><code>cargo install diesel_cli --no-default-features --features postgres</code></li>
<li><code>cargo build --release</code></li>
</ul>
<p>第一步实际上是安装 <code>diesel_cli</code> ，这是为了项目的 数据库 Migration 服务的，因为在 <code>entrypoint.sh</code> 需要调用 <code>diesel migration run</code> 命令来更新数据库。</p>
<p>第二步则是构建我们自己的项目。</p>
<p>那么在这个场景下，第一步看似是多余的，<code>diesel_cli</code> 的作者肯定对自己的项目用 CI 跑过，测试过。那么我们是否能通过构建好的镜像来缩减这一步的耗时呢。</p>
<h2>使用打包好的基础镜像</h2>
<p>结论是可以的，虽然该库的作者并没有提供这么一个 Docker 镜像，但是社区上面有人封装过了 <code>clux/diesel_cli</code>， 所以我们可以用以下的方法来缩减我们构建的时间。</p>
<pre><code class="language-dockerfile">FROM clux/muslrust:nightly as builder
COPY . /app
WORKDIR /app
RUN cargo build --release

FROM clux/diesel-cli
COPY --from=builder /app/target /application/target
COPY --from=builder /app/migrations /application/migrations
COPY --from=builder /app/Rocket.toml /application/Rocket.toml
COPY --from=builder /app/entrypoint.sh /application/entrypoint.sh
COPY --from=builder /app/target/x86_64-unknown-linux-musl/release/rubble /application/rubble

EXPOSE 8000
WORKDIR /application
CMD [&quot;sh&quot;, &quot;./entrypoint.sh&quot;]
</code></pre>
<p>那么在看回这个构建过程，只剩下一步耗时操作 <code>cargo build --release</code> ，我们自己项目的构建过程，这里看似不能再做时间的缩减了，实则不然。</p>
<p>我们来分析一下构建步骤内部是如何操作的：</p>
<ul>
<li>分析 <code>Cargo.toml</code> 和 <code>Cargo.lock</code> 来确定该应用所依赖的库和库的版本</li>
<li>从 <code>Crates</code> 下载这些制定版本的库</li>
<li>编译这些依赖库</li>
<li>编译自己的应用</li>
</ul>
<blockquote>
<p>在做深入的分析之前，我们先要了解一下 <code>docker build</code> 的缓存机制，简单来说，docker 会对 dockerfile 中的每一步操作进行记录，尤其是 <code>COPY</code> 和 <code>ADD</code> 操作，如果 COPY 之后的 文件HASH值（这里值的是整个 docker 镜像的哈嘻之）不变，那么在COPY 之后的 RUN 都会沿用之前的运行结果，直接命中缓存。</p>
<p>来一个例子是说，假设我们写一个这样的Dockerfile</p>
<pre><code class="language-dockerfile">copy test.txt
RUN cp test.txt copy.txt
</code></pre>
<ul>
<li>第一次执行，我们传入了内容为 <code>hello world</code> 的 <code>test.txt</code> 文件，docker得到执行后的hash <code>A</code>，然后只想步骤二，得到 hash <code>B</code>。</li>
<li>第二次执行该脚本时，如果执行完第一步得到的hash值还是 <code>A</code> 的话，那么 docker 会跳过执行步骤二，直接去缓存下来的结果。</li>
</ul>
</blockquote>
<p>因为每次构建都是对自己项目的全新构建，那么我们可以考虑把下载和编译依赖库的步骤缓存下来。</p>
<h2>缓存项目的 Rust 依赖</h2>
<p>为了缓存项目的依赖部分，我们把 Project Rubble 的 Dockerfile 构建改成了一下的样子：</p>
<pre><code class="language-dockerfile">FROM clux/muslrust:stable as builder

WORKDIR /app

RUN USER=root cargo new rubble
WORKDIR /app/rubble

COPY Cargo.toml Cargo.lock ./

RUN echo 'fn main() { println!(&quot;Dummy&quot;) }' &gt; ./src/main.rs

RUN cargo build --release

RUN rm -r target/x86_64-unknown-linux-musl/release/.fingerprint/rubble-*

COPY src src/
COPY migrations migrations/
COPY templates templates/

RUN cargo build --release --frozen --bin rubble


FROM alpine:latest

COPY --from=builder /app/rubble/migrations /application/migrations
COPY --from=builder /app/rubble/templates /application/templates
COPY --from=builder /app/rubble/target/x86_64-unknown-linux-musl/release/rubble /application/rubble

EXPOSE 8000

ENV DATABASE_URL postgres://root@postgres/rubble

WORKDIR /application
CMD [&quot;./rubble&quot;]
</code></pre>
<p>这个构建过程相比于上一个版本，可以拆成两个小的步骤</p>
<h3>构建假的项目，下载并编译依赖</h3>
<pre><code class="language-dockerfile">RUN USER=root cargo new rubble
WORKDIR /app/rubble
COPY Cargo.toml Cargo.lock ./
RUN echo 'fn main() { println!(&quot;Dummy&quot;) }' &gt; ./src/main.rs
RUN cargo build --release
</code></pre>
<p>相比之前的把所有源文件一起复制到 docker 镜像，这次首先把 <code>Cargo.toml</code> <code>Cargo.lock</code> 拷贝过去，然后新建一个虚拟的、假的 <code>main.rs</code> 来伪造项目入口，为的是保证项目能够正常构建。</p>
<p>那么根据刚刚描述的 Docker 构建缓存策略，如果我们传入的两个 Cargo 文件不变（指的是项目所依赖的内容不变）的情况下，那么我们就不会在每次构建的时候都会下载和编译这些依赖，完全可以复用原来编译好的依赖。</p>
<h3>删除自己项目的构建信息</h3>
<pre><code class="language-dockerfile">RUN rm -r target/x86_64-unknown-linux-musl/release/.fingerprint/rubble-*
</code></pre>
<p>这条命令是把自己项目的构建信息删除，因为我这里用的是项目 <code>rubble</code> 的信息，所以如果要使用到自己的项目中，请就保证这里删除的目录是正确的。</p>
<p>这里删除的应该是构建二进制文件的指纹 <code>fingerprint</code>，其实我也不太清楚为什么在 docker 构建的时候需要删除，在日常编译中却不需要，不太了解 cargo 的运行机制。但是著者试过，如果不删除这个文件，那么在下一步的真正编译项目中便会不成功。</p>
<h3>真正的构建过程</h3>
<pre><code class="language-dockerfile">COPY src src/
COPY migrations migrations/
COPY templates templates/

RUN cargo build --release --frozen --bin rubble
</code></pre>
<p>这里就是真正地把项目源文件拷贝进 docker 镜像进行编译</p>
<h3>最小化运行镜像</h3>
<pre><code class="language-dockerfile">FROM alpine:latest

COPY --from=builder /app/rubble/migrations /application/migrations
COPY --from=builder /app/rubble/templates /application/templates
COPY --from=builder /app/rubble/target/x86_64-unknown-linux-musl/release/rubble /application/rubble

EXPOSE 8000

ENV DATABASE_URL postgres://root@postgres/rubble

WORKDIR /application
CMD [&quot;./rubble&quot;]
</code></pre>
<p>这一步是可选的，因为 Rust 项目编译之后便不依赖于 Cargo 环境了，编译后的二进制文件可以直接在其对应的平台上运行，所以选择了一个最小的可运行平台来跑，以缩减系统其他套件带来的资源消耗。</p>
<p>至此，我们把整个构建过程能缓存的部分都用缓存实现了，从之前的构建1个小时，到现在在不更新依赖的情况下10分钟完成构建，这个提升还是挺显著的。</p>
<p>此外，项目还重新选择了 <code>embbed_migration</code> 来做数据库迁移工作，有意可以参考下 <a href="https://docs.rs/diesel_migrations/1.4.0/diesel_migrations/">diesel_migrations</a></p>
]]></content:encoded>
        </item>
        
            
        <item>
            <title>自动解引用.RUST</title>
            <link>https:&#x2F;&#x2F;www.kilerd.me/rust-auto-deref</link>
            
            <description><![CDATA[<p>解引用应该说是 Rust 为了解决不采用 Class 来实现对象化编程的一个解决方案。假想一下如果 Python 或者 Java 之流，需要对一个结构体（准确来说应该是类）进行自定义扩展：增加字段，增加方法，重写方法等等，我们可以直接用继承的方式来实现</p>
<pre><code class="language-python">class Base:
	a: int = 2

class Extend(Base):
	my_self_field: int = 3
</code></pre>
<p>当一个函数希望传入实现了 <code>Base</code> 类的所有实例时，可以直接以 <code>Base</code> 为约束，限定其参数范围。在 Java 中就可以使用基类或者 Interface 来约束。</p>
<pre><code class="language-python">def base_bound(param: Base):
    pass
</code></pre>
<p>这一套在 Rust 并不适用，在 Rust 中时采用 Struct + Trait 来抽象对象化。所以若想对结构体进行扩展，那么就只能再用一层结构体去包（wrap）住原来的结构体。</p>
<pre><code class="language-rust">struct MyOwnDerefStruct(String);
</code></pre>
]]></description>
            
            <guid>https:&#x2F;&#x2F;www.kilerd.me/rust-auto-deref</guid>
            <pubDate>Thu, 18 Apr 2019 06:11:25 +0800</pubDate>
            <content:encoded><![CDATA[<p>解引用应该说是 Rust 为了解决不采用 Class 来实现对象化编程的一个解决方案。假想一下如果 Python 或者 Java 之流，需要对一个结构体（准确来说应该是类）进行自定义扩展：增加字段，增加方法，重写方法等等，我们可以直接用继承的方式来实现</p>
<pre><code class="language-python">class Base:
	a: int = 2

class Extend(Base):
	my_self_field: int = 3
</code></pre>
<p>当一个函数希望传入实现了 <code>Base</code> 类的所有实例时，可以直接以 <code>Base</code> 为约束，限定其参数范围。在 Java 中就可以使用基类或者 Interface 来约束。</p>
<pre><code class="language-python">def base_bound(param: Base):
    pass
</code></pre>
<p>这一套在 Rust 并不适用，在 Rust 中时采用 Struct + Trait 来抽象对象化。所以若想对结构体进行扩展，那么就只能再用一层结构体去包（wrap）住原来的结构体。</p>
<pre><code class="language-rust">struct MyOwnDerefStruct(String);
</code></pre>
<!--more-->
<p>这里我们就对 <code>String</code> 进行了自己的封装，这里并没有对字段进行扩展，但是这确实在 Rust 中比较常见的场景：一旦我们希望对某个特定的 Struct 实现某个特定的 Trait，同时 Struct 和 Trait 都来自第三方库（不在当前库中定义），那么为了实现<code>impl Trait for Struct</code> ，我们就需要解决孤儿定律（Orphan Rule），此时我们就可以用这种简单的包装方式来满足他。</p>
<blockquote>
<h5>什么是孤儿定律 Orphan Rule？</h5>
<p>在 Rust 中， 若想对 Struct 实现一个 Trait， 那么 Struct 和 Trait 一定要有一方是在当前库中定义的。</p>
<p>这个约束很好理解，也很适用。</p>
<p>假设一个场景：C 库中对 A 的 Struct 实现了 B 中的 Trait。此时我们在当前库中使用了 C 库和 A 库，那么我们可能会对 A 中的 Struct 误解，其可能已经被继承了很多奇怪的 Trait，会严重影响我们对 Struct 的使用</p>
</blockquote>
<p>同时，Rust 为了移除运行时和 GC 的消耗，实现了诸多智能指针：<code>Box</code> <code>Rc</code> <code>Arc</code> 等等。所以可能会出现诸如以下的包装 <code>let param: Arc&lt;Mutex&lt;Box&lt;Vec&lt;i32&gt;&gt;&gt;&gt;;</code> 这种在 Python 中只是简单的 <code>a: List&lt;int&gt;</code> 的包装。</p>
<p>为了方便这种因为语言特性导致的额外包装，Rust 提供了自动解引用 <code>Deref</code> 来简化编程。</p>
<pre><code class="language-rust">#[lang = &quot;deref&quot;]
#[doc(alias = &quot;*&quot;)]
#[doc(alias = &quot;&amp;*&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub trait Deref {
    /// The resulting type after dereferencing.
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    type Target: ?Sized;

    /// Dereferences the value.
    #[must_use]
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
</code></pre>
<p>若要使用 Deref Trait，我们先看看 Deref 里面有什么东西：</p>
<ul>
<li><code>type Target</code> 指的是我们希望被解引用到那个数据结构。</li>
<li><code>deref()</code> 提供了一个手动调用解引用到 <code>&amp;Target</code> 的方法。</li>
</ul>
<p>回到我们写的 <code>MyOwnDerefStruct</code> 例子，我们包装了 <code>String</code> 类型，如果现在有一个接收 <code>&amp;String</code> 参数的函数，在没有 Deref 的场景我们需要怎么调用他呢？</p>
<pre><code class="language-rust">struct MyOwnDerefStruct(String);

fn print(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let deref_struct = MyOwnDerefStruct(String::from(&quot;hello world&quot;));
    print(&amp;deref_struct.0);
}

</code></pre>
<p>在 L9 中，我们需要先通过 <code>deref_struct.0</code> 获取到 <code>MyOwnDerefStruct</code> 中的第一个属性 <code>String</code> ，然后再通过 <code>&amp;</code> 来转换成 <code>&amp;String</code> 。</p>
<p>如果我们直接用会 C 中的逻辑 <code>print(&amp;deref_struct)</code> ，我们会得到以下的错误信息：</p>
<pre><code>error[E0308]: mismatched types
  --&gt; src/main.rs:23:11
   |
23 |     print(&amp;deref_struct);
   |           ^^^^^^^^^^^^^ expected struct `std::string::String`, found struct `MyOwnDerefStruct`
   |
   = note: expected type `&amp;std::string::String`
              found type `&amp;MyOwnDerefStruct`

</code></pre>
<p>此时如果我们为我们的结构体 <code>MyOwnDerefStruct</code> 实现自动解引用的话，以上代码就可以正常编译：</p>
<pre><code class="language-rust">impl Deref for MyOwnDerefStruct {
    type Target = String;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        return &amp;self.0;
    }
}
</code></pre>
<p>在上述代码中，我们告诉 Rust 编译器：「我们期望 <code>MyOwnDerefStruct</code> 被解到 <code>String</code>」，那么在编译过程中碰到需要 <code>&amp;String</code> 时，编译器会自动帮我们转换。而且我们还能写出以下相当 tricky 的代码 <code>print(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;deref_struct);</code>（这代码能跑的原因，可以自行去看看 Rust 内部对 &amp; 的处理）</p>
<p>自动解引用还有一个好处就是，他可以直接寻址到 <code>Target</code> 的方法。在我们的场景里面，<code>String</code> 中有判断两个字符串是否相等的方法 <code>eq</code> 。因为自动解引用的存在，我们并不需要 <code>deref_struct.0.eq(&quot;hello world&quot;)</code> 的写法。  <code>MyOwnDerefStruct</code> 可以直接调用 <code>eq</code> 方法。</p>
<pre><code class="language-rust">assert_eq!(true, deref_struct.eq(&quot;hello world&quot;));
</code></pre>
<p>这样就避免了在使用智能指针的时候在代码中出现大量的 <code>variable_box.0.method()</code> 。避免了 <code>.0</code> 的出现，大大地简化了代码，同时也增加了代码的可读性。</p>
<h2><code>variable.deref()</code> 和 <code>*variable</code> 的区别</h2>
<p>使用解引用的时候需要注意的是函数 <code>deref()</code> 和 <code>*</code> 的行为是不一样的。</p>
<ul>
<li><code>deref()</code> 的函数原型是 <code>fn deref(&amp;self) -&gt; &amp;Self::Target;</code> 所以我们拿到的是 Target 的引用 <code>&amp;Target</code></li>
<li><code>*</code> 是直接拿到 <code>Target</code></li>
</ul>
<p>所以，简单来说 <code>variable.deref()</code> 就等价于 <code>&amp;*variable</code></p>
]]></content:encoded>
        </item>
        
    </channel>
</rss>