<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="/statics/style.css">
    <link rel="alternate" type="application/rss+xml" title="你好，耳先生" href="/rss.xml" />
    <title>关于 HTTP OPTIONS</title>
</head>

<body>


    <section class="full-page">
        <section class="container">
            <nav>
                <a href="/">HOMEPAGE</a>
                
                
                <a href="/portfolios">PORTFOLIOS</a>
                
                <a href="/my-read">我的阅读</a>
                
                <a href="/about">ABOUTME</a>
                
                
            </nav>
            <section class="single article">
                <p class="mate">June 21, 2017</p>
                <h2>关于 HTTP OPTIONS</h2>
                <section class="content yue">
                    <blockquote>
<p>本文参考了两篇文章：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS">OPTIONS - HTTP | MDN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></li>
</ul>
</blockquote>
<p>首先 OPTIONS 方法不应该像 GET, POST, PUT 等方法一样返回内容，它返回的应该就只有Header。</p>
<p>OPTIONS 的功能基本上只有两个：</p>
<ul>
<li>在普通访问中，它会返回同 URL 中允许访问的 METHODS</li>
<li>在跨域访问 (CORS) 中，返回对应的原站 (Origin) 能访问的METHODS</li>
</ul>
<!--more-->
<h2>普通访问</h2>
<p>在普通访问时：</p>
<pre><code class="language-bash">curl -X OPTIONS http://example.org -i
</code></pre>
<p>返回内容中，就应该包含<code>allow</code>  这个响应头来告知访问者，哪些 METHOD 是已经实现了的(可以访问的)</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST
Cache-Control: max-age=604800
Date: Thu, 13 Oct 2016 11:45:00 GMT
Expires: Thu, 20 Oct 2016 11:45:00 GMT
Server: EOS (lax004/2813)
x-ec-custom-error: 1
Content-Length: 0
</code></pre>
<p>这份响应中的 <code>Allow</code> 就包含了<code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code> 四种方法。</p>
<h2>CORS</h2>
<p>在非简单请求的情况下，先会把需要请求的方法放在<code>request header</code> 中，发送一个<code>OPTIONS</code>方法，检测目的方法是否允许访问。</p>
<pre><code class="language-http">OPTIONS /resources/post-here/ HTTP/1.1 
Host: bar.other 
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
Accept-Language: en-us,en;q=0.5 
Accept-Encoding: gzip,deflate 
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 
Connection: keep-alive 
Origin: http://foo.example 
Access-Control-Request-Method: POST 
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
</code></pre>
<p>上述例子，在访问<code>POST http://foo.example/resources/post-here </code> 之前， 先回发出一个对应的<code>OPTIONS</code> 方法。</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT 
Server: Apache/2.0.61 (Unix) 
Access-Control-Allow-Origin: http://foo.example 
Access-Control-Allow-Methods: POST, GET, OPTIONS 
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type 
Access-Control-Max-Age: 86400 
Vary: Accept-Encoding, Origin 
Content-Encoding: gzip 
Content-Length: 0 
Keep-Alive: timeout=2, max=100 
Connection: Keep-Alive 
Content-Type: text/plain
</code></pre>
<p>其响应报文中有几个参数是值得关注的</p>
<ul>
<li><code>Access-Control-Allow-Origin</code> 这个字段描述了哪些网址可以调用这个API的内容。 如果是都允许，就应该返回<code>*</code> ，反之，应该直接放回对应的域名</li>
<li><code>Access-Control-Allow-Methods</code> 允许访问的METHOD</li>
<li><code>Access-Control-Allow-Headers</code> 在访问时允许添加的头部信息</li>
<li><code>Access-Control-Max-Age</code> 用来标识这次<code>OPTIONS</code> 的信息有效时间。如果在有效期内，那么不需要再重复发送 <code>OPTIONS</code> 请求。</li>
</ul>
<h2>看看 Flask 是怎么处理的</h2>
<pre><code class="language-python">import flask
app = flask.Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    return &quot;hello world&quot;

@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def allow_post_method():
    return &quot;post is allowed here&quot;
</code></pre>
<p>访问<code>OPTIONS /</code> </p>
<pre><code class="language-http">HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD
Content-Length: 0
Content-Type: text/html; charset=utf-8
Date: Wed, 21 Jun 2017 15:14:58 GMT
Server: Werkzeug/0.12.2 Python/3.6.1
</code></pre>
<p>访问<code>OPTIONS /all_post_method</code></p>
<pre><code class="language-http">HTTP/1.1 200 OK
Allow: POST, GET, OPTIONS, HEAD
Content-Length: 0
Content-Type: text/html; charset=utf-8
Date: Wed, 21 Jun 2017 15:38:35 GMT
Server: Werkzeug/0.12.2 Python/3.6.1
</code></pre>
<p>也就是说，一般的框架都会自动帮你实现 <code>HEAD</code> 和 <code>OPTIONS</code>  方法。</p>
<h2>Nougat 该怎么办</h2>
<p>现在Nougat 是需要自己定义<code>HEAD</code> 和 <code>OPTIONS</code> 方法的。那么说来，这两个方法需要自动实现。</p>
<p>那么对于 <code>Access-Control-Allow-Origin</code> 这个处理方法的话。</p>
<p>我大概会这样设计</p>
<p>对于一个 Section 来说，可以在整个模块的层面上，允许所有 Section 内的 API 都允许这个域来访问，因此这样设计会比较妥当：</p>
<pre><code class="language-python">api = Section(&quot;api&quot;)
app.allows([&quot;example.com&quot;, &quot;a.com&quot;])
# or
app.allows(&quot;*.(example|a).com&quot;)
</code></pre>
<p>现在的想法是，传入一个允许的域列表，或者传入一个正则。</p>
<p>那么对单个 API 来说，也可以在 Section 之外指定其他的域。</p>
<pre><code class="language-python">@api.get(&quot;/&quot;)
@api.allow(&quot;*.b.com&quot;)
async def one_api(ctx):
    pass
</code></pre>
<p>使用 <code>allow</code> 装饰器来传入一个正则，相对于 Section 允许的内容额外添加一部分域。</p>
<p>不过这样设计之后，对于以下例子</p>
<pre><code class="language-python">api = Secion(&quot;api&quot;)
app.allows(&quot;a.com&quot;)

@api.get(&quot;/&quot;)
async def get(ctx):
    pass

@api.post(&quot;/&quot;)
@api.allow(&quot;b.com&quot;)
async def post(ctx):
    pass
</code></pre>
<p>按照上述例子中 <code>Access-Control-Allow-Methods</code> 是返回所有允许访问的方法。</p>
<p>那么如果这时候访问<code>OPTION /</code> ， <code>Access-Control-Allow-Methods</code> 应该就是 <code>OPTIONS, HEAD, GET, POST</code> ， 那么<code>Access-Control-Allow-Origin</code> 应该返回什么内容呢： <code>a.com</code> 还是<code>a.com, b.com</code> 。</p>
<p>如果是前者，那么 <code>POST / </code> 是允许 <code>b.com </code>的； 如果是后者， <code>GET /</code> 是不允许<code>a.com</code>。</p>
<p>还是说存在一种可能性，存在一份 RFC， 讲明了对于一个URL，无论是什么方法， <code>Access-Control-Allow-Origin</code> 的值都要是一样的。</p>
<p><strong>以上关于 Nougat 的一切代码，纯属虚构。并未实现，具体效果请等正式代码出来</strong></p>

                </section>
            </section>
        </section>
    </section>


    <footer>
        <section class="container">
            <p> 自豪地使用 <a href="https://github.com/Kilerd/rubble">Project Rubble</a> 运行。 </p>
            <div style="display:none"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-68997851-1"></script> <script>   window.dataLayer = window.dataLayer || [];   function gtag(){dataLayer.push(arguments);}   gtag('js', new Date());    gtag('config', 'UA-68997851-1'); </script>
</div>
        </section>
    </footer>
    <script src="/statics/prism.js" type="text/javascript"></script>
</body>

</html>